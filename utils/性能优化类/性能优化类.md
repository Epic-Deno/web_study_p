### 1、函数防抖(debounce)

- 原理：事件被触发n秒执行函数的回调，如果在这n秒内又被触发，则重新计时。

看一个简单的例子，模拟一个ajax请求。

```html
<div>
    没有防抖的input：<input type="text" id="input">
</div>
```



```js
const ajax = (val) => {
      console.log('ajax request ' + val)
}
let getVal = document.getElementById("input");
getVal.addEventListener("keyup",function() {
    let that = this;
    ajax(that.value)
})
```

**执行回调结果如图：**

![2018-09-04 09 23 46](https://user-gold-cdn.xitu.io/2018/9/4/165a252be5c94d6b?imageslim)

​	可以看到，我们只要按下键盘，就会触发这次ajax请求。不仅从资源上来说是很浪费的行为，而且实际应用中，用户也是输出完整的字符后，才会请求。下面我们优化一下：

```js
function debounce(fn,delay) {
    let timer = null; // 定时器
    return function() {
        let that = this;
        let args = arguments;
        if(timer) {
            clearTimeOut(timer);
            timer = null;
        }
        timer = setTimeOut(() => {
            fn.apply(that, args)
        },delay)
    }
}
const ajax = (val) => {
      console.log('ajax request ' + val)
}
let debounceAjax = ajax(ajax, 500)
let getVal = document.getElementById("input");
getVal.addEventListener("keyup",function() {
    let that = this;
    debounceAjax(that.value)
})
```

运行结果：

![2018-09-04 09 29 50](https://user-gold-cdn.xitu.io/2018/9/4/165a252b4b429b56?imageslim)

可以看到，我们加入了防抖以后，当你在频繁的输入时，并不会发送请求，只有当你在指定间隔内没有输入时，才会执行函数。如果停止输入但是在指定间隔内又输入，会重新触发计时

### 2、函数节流(throttle)

- 规定在一个单位时间内，只能触发一次函数。如果这个单位时间内触发多次函数，只有一次生效。

```js
function throttle(fn, delay) {
    let timer = null;
    let lastTime = null;
    return function(args) {
        let _args = arguments;
        let that = this;
        let newTime = + new Date();
        if(lastTime && newTime < lastTime + delay) {
            clearTimeout(timer);
            timer = setTimeout(() => {
                lastTime = newTime;
                fn.apply(that, _args)
            },delay)
        }else {
            lastTime = newTime;
            fn.apply(that, _args)
        }
    }
}
let getVal2 = document.getElementById("input2");
let throttleAjax = throttle(ajax,1000)
getVal2.addEventListener("keyup",function() {
    let that = this;
    throttleAjax(that.value)
})
```

运行结果：

![2018-09-04 09 36 49](https://user-gold-cdn.xitu.io/2018/9/4/165a252b4c1a9686?imageslim)

#### 总结

- 函数防抖和函数节流都是防止某一时间频繁触发，但是这两兄弟之间的原理却不一样。
- 函数防抖是某一段时间内只执行一次，而函数节流是间隔时间执行。

#### 结合应用场景

- debounce 
  - search搜索，用户在不断输入值时，用防抖来节约请求资源。
  - window触发resize的时候，不断的调整浏览器窗口大小会不断的触发这个事件，用防抖来让其只触发一次
- throttle 
  - 鼠标不断点击触发，mousedown(单位时间内只触发一次)
  - 监听滚动事件，比如是否滑到底部自动加载更多，用throttle来判断