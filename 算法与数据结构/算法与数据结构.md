# 前端算法与数据结构

[leetcode 官方网址](https://leetcode-cn.com/)

#### 1、算法和数据结构含义

- 数据结构：计算机存储，组织数据的方式
- 算法：一系列解决问题的清晰指令

##### 1-1 关系

- 程序 = 数据结构 + 算法
- 数据结构为算法提供服务，算法围绕数据结构进行操作

##### 1-2 数据结构

- 栈、队列、链表（有序）
- 集合、字典（无序）
- 树、堆、图（有一定连接关系）

##### 1-3 算法

- 链表：遍历链表、删除节点链表
- 树、图：深度/广度优先遍历
- 数组：冒泡/选择/插入/快速排序等等

#### 2、leetcode 的介绍

##### 2-1 功能

- 题库、社区、竞赛、模拟刷题

![1620272226001](https://7775-wujianfeng-6g8spsvm7152bed9-1258453358.tcb.qcloud.la/typora-user-images/1620272226001.png)

![1620272326589](https://7775-wujianfeng-6g8spsvm7152bed9-1258453358.tcb.qcloud.la/typora-user-images/1620272326589.png)

- 做题
  - 查看题目描述，评论，题解，提交记录
  - ![1620272463634](https://7775-wujianfeng-6g8spsvm7152bed9-1258453358.tcb.qcloud.la/typora-user-images/1620272463634.png)

#### 3、时间复杂度

- 一个函数，用大写 O 来表示，比如：O(1)、O(n)、O(n^2)...等等

![图解](https://bkimg.cdn.bcebos.com/pic/dcc451da81cb39db86d6cf67dd160924ab1830e8?x-bce-process=image/watermark,image_d2F0ZXIvYmFpa2U4MA==,g_7,xp_5,yp_5/format,f_auto)

- 时间复杂度为 O(1)

  ```javascript
  let i = 0;
  i = i + 1;
  ```

- 时间复杂度为 O(n)

  ```javascript
  for (let i = 0; i < n; i++) {
    console.log(i);
  }
  // 在一个for循环体里面，这个循环做了n次
  ```

- 时间复杂度为：O(n) + O(1) = O(n)

```javascript
let i = 0;
i = i + 1;
for (let i = 0; i < n; i++) {
  console.log(i);
}
```

- 时间复杂度为：O(n) \* O(n) = O(n^2)

```javascript
for (let i = 0; i < n; i++) {
  for (let j = 0; j < n; j++) {
    console.log(i, j);
  }
}
```

- 时间复杂度为：O(logN)

```javascript
let i = 1;
while (i < n) {
  console.log(i);
  i *= 2;
}
// 如果a^x =N（a>0，且a≠1），那么数x叫做以a为底N的对数，记作x=logaN
```

#### 4、空间复杂度

- 一个函数，用大写 O 来表示，比如：O(1)、O(n)、O(n^2)...等等
- 算法在运行过程中临时占用存储大小的量度。_你写的代码占用的空间大小_

- 空间复杂度为 O(1)

```javascript
let i = 0;
i = i + 1;
```

- 空间复杂度为 O(n)

```javascript
let arr = [];
for (let i = 0; i < n; i++) {
  arr.push(i);
}
```

- 空间复杂度为：O(n^2)

```javascript
let arr = [];
for (let i = 0; i < n; i++) {
  arr.push([]);
  for (let j = 0; j < n; j++) {
    arr[i].push(j);
  }
}
// 矩阵，本质二维数组
```

#### 5、栈

##### 5-1 栈简介

- 栈是一个后进先出的数据结构

![1620283277523](https://7775-wujianfeng-6g8spsvm7152bed9-1258453358.tcb.qcloud.la/typora-user-images/1620283277523.png)

- JavaScript 中没有栈，可以用 Array 数组实现栈的所有功能
  - 代码实现，定义一个 stack 的空数组，在 push 方法打上断点，按 F5，编辑器自带的 js 调试，点击箭头执行下一步操作，左边控制面板可以看出：先入栈的元素是‘a’，先出栈的元素是'd'，满足后进先出原则。
- 栈常用操作：push、pop、stack[stack.length - 1]

![1620298107492](https://7775-wujianfeng-6g8spsvm7152bed9-1258453358.tcb.qcloud.la/typora-user-images/1620298107492.png)

![1620298169848](https://7775-wujianfeng-6g8spsvm7152bed9-1258453358.tcb.qcloud.la/typora-user-images/1620298169848.png)

##### 5-2 栈应用

- 十进制转二进制

  - 倒叙写二进制

  ![1620289310238](https://7775-wujianfeng-6g8spsvm7152bed9-1258453358.tcb.qcloud.la/typora-user-images/1620289310238.png)

- 判断字符串的括号是否有效

  - 越靠后的左括号，对应的右括号越靠前。
  - 从左到右遍历括号，遇到左括号入栈，遇到右括号出栈，最后栈空了就是合法的。

  ![1620289355548](https://7775-wujianfeng-6g8spsvm7152bed9-1258453358.tcb.qcloud.la/typora-user-images/1620289355548.png)

- 函数调用堆栈

  - 最后调用的函数，最先执行完。
  - JS 解释器使用栈来控制函数的调用顺序

```javascript
function run() {
  console.log("1");
  sayHello();
  console.log("2");
}
function sayHello() {
  console.log("hello");
}
run();
// 1
// hello
// 2
```

##### 5-3 栈算法题解析

- 十进制转二进制

```javascript
// num 十进制数字
function get2bin(num) {
  const stack = [];
  while (num > 0) {
    stack.push(num % 2); // 除以2的余数入栈
    num = Math.floor(num / 2); // 获取整除后的结果
  }
  // 定义数组，存放二进制的数
  var arr = [];
  while (stack.length > 0) {
    arr.push(stack.pop());
  }
  console.log(arr);
  return arr.join("");
}
get2bin(35); // 1, 0, 0, 0, 1, 1
```

- #### [20. 有效的括号](https://leetcode-cn.com/problems/valid-parentheses/)

- 对于没有闭合的左括号而言，越靠后的左括号，对应的右括号就越靠前

- 满足后进先出，考虑用栈解决。

- 解题步骤

  - 1、新建一个栈
  - 2、循环字符串，遇到左括号入栈，遇到右括号出栈，遇到类型不匹配判定为不合法。
  - 3、最后栈空了就合法

  ```javascript
  var isValid = function (s) {
    const stack = []; // 新建一个栈
    if (s.length % 2 == 1) {
      return false; // 奇数的长度直接不合法
    }
    for (let i = 0; i < s.length; i++) {
      const val = s[i];
      if (val === "(" || val === "{" || val === "[") {
        stack.push(val); // 判断左括号合法，入栈
      } else {
        const top = stack[stack.length - 1]; // 定义栈顶元素
        if (
          // 栈顶元素的栈底元素匹配
          (top === "(" && val === ")") ||
          (top === "{" && val === "}") ||
          (top === "[" && val === "]")
        ) {
          stack.pop(); // 出栈
        } else {
          return false;
        }
      }
    }
    return stack.length === 0; // 栈空了就合法
  };
  isValid("()");
  isValid("()[]{}");
  isValid("(]");
  isValid("([)]");
  ```

##### 5-4 前端与栈

- 函数的调用（按循序去执行函数）

```javascript
const fn1 = () => {
  fn2();
};
const fn2 = () => {
  fn3();
};
const fn3 = () => {};
fn1();
// 最先执行的函数是fn1 -> fn2 -> fn3
```

- 执行入栈

![1620293610769](https://7775-wujianfeng-6g8spsvm7152bed9-1258453358.tcb.qcloud.la/typora-user-images/1620293610769.png)

- 执行出栈

![1620293713165](https://7775-wujianfeng-6g8spsvm7152bed9-1258453358.tcb.qcloud.la/typora-user-images/1620293713165.png)

#### 6、队列

##### 6-1 队列简介

- 队列是先进先出的数据结构

  ![1620294367021](https://7775-wujianfeng-6g8spsvm7152bed9-1258453358.tcb.qcloud.la/typora-user-images/1620294367021.png)

- JavaScript 中没有队列，可以用 Array 数组实现队列的所有功能

- 入队和出队

- 队列常用操作：push、shift、queue[0]

![1620295210652](https://7775-wujianfeng-6g8spsvm7152bed9-1258453358.tcb.qcloud.la/typora-user-images/1620295210652.png)

![1620295280606](https://7775-wujianfeng-6g8spsvm7152bed9-1258453358.tcb.qcloud.la/typora-user-images/1620295280606.png)

##### 6-2 队列应用

- 排队打饭
- JS 异步中的任务队列
  - JS 是单线程的，无法同时处理异步中的并发任务。
  - 使用队列任务先后处理异步任务
- 计算最近请求次数

##### 6-3 队列算法题解析

- #### [933. 最近的请求次数](https://leetcode-cn.com/problems/number-of-recent-calls/)

- 解题步骤

  - 有新情求就入队，3000ms 前发出的请求出队
  - 队列的长度就是最近的请求次数

  ```javascript
  // 在这个时间 的 过去 3 秒 内, 不停的请求, 求在这个3秒内这个请求了多少下
  var RecentCounter = function () {
    this.queue = [];
  };

  /**
   * @param {number} t
   * @return {number}
   */
  RecentCounter.prototype.ping = function (t) {
    this.queue.push(t);
    // 队头在 t - 3000ms内，出队
    while (this.queue[0] < t - 3000) {
      this.queue.shift();
    }
    return this.queue.length;
  };
  // 时间复杂度：O(n) , 空间复杂度O(n)
  ```

##### 6-4 前端与队列

- Javascript 语言的执行环境是**单线程**的。[js 异步原理解析](https://blog.csdn.net/happyqyt/article/details/90644667)

  所谓"单线程"，就是指一次只能完成一件任务。如果有多个任务，就必须排队，前面一个任务完成，再执行后面一个任务，以此类推。

![1620300436833](https://7775-wujianfeng-6g8spsvm7152bed9-1258453358.tcb.qcloud.la/typora-user-images/1620300436833.png)

#### 7、链表

##### 7-1 链表简介

- 多个元素组成的列表
- 元素存储不连续，用 next 指针连在一起

![1620301104532](https://7775-wujianfeng-6g8spsvm7152bed9-1258453358.tcb.qcloud.la/typora-user-images/1620301104532.png)

- JS 没有链表
- 可以用 Object 模拟链表

![1620301659309](https://7775-wujianfeng-6g8spsvm7152bed9-1258453358.tcb.qcloud.la/typora-user-images/1620301659309.png)

- 遍历链表

  ```javascript
  var a = {
    val: "a",
  };
  var b = {
    val: "b",
  };
  var c = {
    val: "c",
  };
  var d = {
    val: "d",
  };

  a.next = b;
  b.next = c;
  c.next = d;
  // 如此一来，就创建了一个链表
  // 遍历链表

  let p = a;
  while (p) {
    console.log(p.val);
    p = p.next;
  }
  ```

![1620301903085](https://7775-wujianfeng-6g8spsvm7152bed9-1258453358.tcb.qcloud.la/typora-user-images/1620301903085.png)

- 链表插入

  ![1620302297070](https://7775-wujianfeng-6g8spsvm7152bed9-1258453358.tcb.qcloud.la/typora-user-images/1620302297070.png)

  - 链表删除

  ```javascript
  // 删除
  c.next = d; // 把c的next指向d,就能删除e
  ```

##### 7-2 链表算法题解析

- #### [237. 删除链表中的节点](https://leetcode-cn.com/problems/delete-node-in-a-linked-list/)

- 解题思路

  - 无法直接获取被删除节点的上一个元素，将被删除节点的值改成下个节点的值
  - 将被删除节点转移到下个节点（如果想要删除节点 5，先把 5 的节点指向下个元素值，此时链表为 4-1-1-9，再把节点 1 下个元素删除，即可得到 4-1-9 的链表）

  ```javascript
  /**
   * Definition for singly-linked list.
   * function ListNode(val) {
   *     this.val = val;
   *     this.next = null;
   * }
   */
  /**
   * @param {ListNode} node
   * @return {void} Do not return anything, modify node in-place instead.
   */
  var deleteNode = function (node) {
    node = 5;
    node.val = node.next.val;
    node.next = node.next.next;
  };
  ```

  - [206. 反转链表](https://leetcode-cn.com/problems/reverse-linked-list/)

  - [2. 两数相加](https://leetcode-cn.com/problems/add-two-numbers/)

  - [141. 环形链表](https://leetcode-cn.com/problems/linked-list-cycle/)

##### 7-4 前端与链表

###### 7-4-1 JS 原型链含义

- 原型链的本质是链表
- 原型链上的节点是各个原型对象，比如`Function.prototype`、`Object.prototype`
- 原型链通过`__proto__`属性连接各种原型对象

###### 7-4-2 原型链

```javascript
obj -> Object.prototype -> null
fun -> Function.prototype -> Object.prototype -> null
arr -> Array.prototype -> Object.prototype -> null
```

![1620354676155](https://img-blog.csdnimg.cn/20210507112153700.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1dlYl9TdHJ1Z2dsZQ==,size_16,color_FFFFFF,t_70)

###### 7-4-3 原型链知识点

- 如果`A`沿着原型链能找到`B.prototype`，那么`A` `instanceof B` 为 true

```javascript
const obj = {};
const fun = () => {};
const arr = [];
// 对于数组来说，arr即是Array的实例，也是Object的实例
arr instanceof Array; // true
arr instanceof Object; // true
fun instanceof Function; // true
fun instanceof Object; // true
obj instanceof Object; // true
```

- 如果在 A 对象上没有找到 X 属性，那么会沿着原型链找到 X 的属性

```javascript
const obj = {};
obj.name = undefined;
Object.prototype.name = "张三";
obj.name = "张三";
// 函数原型链可以指向Object.prototype
Object.prototype.age = "16";
const fun1 = () => {};
fun1.age = 16;
```

![1620357599056](https://img-blog.csdnimg.cn/20210507112225459.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1dlYl9TdHJ1Z2dsZQ==,size_16,color_FFFFFF,t_70)

![1620358057065](https://img-blog.csdnimg.cn/20210507112748896.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1dlYl9TdHJ1Z2dsZQ==,size_16,color_FFFFFF,t_70)

#### 8、集合

- 集合是一个无序且唯一的数据结构
- ES6 中有集合，Set 数据结构

##### Set 常用方法

```js
// set数据结构常见用法

// 去重

const arr = [1, 1, 2, 3, 4, 5, 3, 4];

const arr2 = [...new Set(arr)]; // [1,2,3,4,5]

// 判断元素是否在集合里

const set = new Set(arr);

const set1 = set.has(1); // true
const set2 = set.has(6); // false

// 求交集

const set3 = new Set([1, 2]);
const el = new Set([...set].filter((item) => set3.has(item))); // [1,2]

// set add方法

const addSet = new Set();
addSet.add(1);
const obj = {
  a: 1,
  b: 2,
};
addSet.add({
  a: 1,
  b: 2,
});
addSet.add(obj); // addSet同时存在两个对象，obj和 {a:1,b:2}两个对象存储的地址不一样
const set4 = addSet.has(obj); // true
const set5 = addSet.has({
  // false
  a: 1,
  b: 2,
});

// delete 删除集合
addSet.delete(1);
addSet.delete(obj);
```

3、遍历操作

Set 结构的实例有四个遍历方法，可以用于遍历成员。

- `Set.prototype.keys()`：返回键名的遍历器
- `Set.prototype.values()`：返回键值的遍历器
- `Set.prototype.entries()`：返回键值对的遍历器
- `Set.prototype.forEach()`：使用回调函数遍历每个成员

需要特别指出的是，`Set`的遍历顺序就是插入顺序。这个特性有时非常有用，比如使用 Set 保存一个回调函数列表，调用时就能保证按照添加顺序调用。

```javascript
// Array.from方法可以将 Set 结构转为数组。
const items = new Set([1, 3, 4, 5, 6, 6, 7, 7]);
console.log(items);
const arr = Array.from(items);
console.log(arr); // [1,3,4,5,7]
// keys返回健明
for (let set of items.keys()) {
  console.log(set); // 1, 3, 4, 5, 6, 7
}
// values返回键值
for (let set of items.values()) {
  console.log(set); // 1, 3, 4, 5, 6, 7
}
// entries方法返回的遍历器，同时包括键名和键值，所以每次输出一个数组，它的两个成员完全相等。
for (let set of items.entries()) {
  console.log(set); // [1, 1] [3, 3] [4, 4] [5, 5] [6, 6] [7, 7]
}
```

Set 结构的实例默认可遍历，它的默认遍历器生成函数就是它的`values`方法。

```javascript
Set.prototype[Symbol.iterator] === Set.prototype.values;
// true
```

这意味着，可以省略`values`方法，直接用`for...of`循环遍历 Set。

```javascript
// 简便写法
const item2 = new Set(["a", "b", "c", "d"]);
for (const set of item2) {
  console.log(set);
}
```

**遍历的应用**

扩展运算符（`...`）内部使用`for...of`循环，所以也可以用于 Set 结构。

```javascript
let set = new Set(["red", "green", "blue"]);
let arr = [...set];
// ['red', 'green', 'blue']
```

扩展运算符和 Set 结构相结合，就可以去除数组的重复成员。

```javascript
let arr = [3, 5, 2, 2, 5, 5];
let unique = [...new Set(arr)];
// [3, 5, 2]
```

而且，数组的`map`和`filter`方法也可以间接用于 Set 了。

```javascript
let set = new Set([1, 2, 3]);
set = new Set([...set].map((x) => x * 2));
// 返回Set结构：{2, 4, 6}

let set = new Set([1, 2, 3, 4, 5]);
set = new Set([...set].filter((x) => x % 2 == 0));
// 返回Set结构：{2, 4}
```

因此使用 Set 可以很容易地实现并集（Union）、交集（Intersect）和差集（Difference）。

```javascript
let a = new Set([1, 2, 3]);
let b = new Set([4, 3, 2]);

// 并集
let union = new Set([...a, ...b]);
// Set {1, 2, 3, 4}

// 交集
let intersect = new Set([...a].filter((x) => b.has(x)));
// set {2, 3}

// （a 相对于 b 的）差集
let difference = new Set([...a].filter((x) => !b.has(x)));
// Set {1}
```

##### [349. 两个数组的交集](https://leetcode-cn.com/problems/intersection-of-two-arrays/)

```js
var intersection = function (nums1, nums2) {
  const set1 = new Set(nums1);
  const set2 = new Set([...nums2].filter((item) => set1.has(item)));
  return [...new Set(set2)];
};
const nums1 = [1, 2, 2, 1];
const nums2 = [2, 2];
intersection(nums1, nums2);
console.log(intersection(nums1, nums2));
```

#### 9、字典

- 与集合类似，字典也是存储唯一值得数据结构，是以键值对(映射关系)的形式来存储
- ES6 中有字典，Map

##### 1、基本用法

ES6 提供了 Map 数据结构。它类似于对象，也是键值对的集合，但是“键”的范围不限于字符串，各种类型的值（包括对象）都可以当作键。也就是说，Object 结构提供了“字符串—值”的对应，Map 结构提供了“值—值”的对应，是一种更完善的 Hash 结构实现。如果你需要“键值对”的数据结构，Map 比 Object 更合适。

```javascript
const m = new Map();
m.set("name", "张三");
m.get("name");
console.log(m.get("name")); // 张三
console.log(m.has("name")); // true
console.log(m.has("age")); // false
console.log(m.delete("name")); // true
console.log(m.has("name")); // false
```

作为构造函数，Map 也可以接受一个数组作为参数。该数组的成员是一个个表示键值对的数组。

```javascript
const map = new Map([
  ["name", "张三"],
  ["title", "Author"],
]);

map.size; // 2
map.has("name"); // true
map.get("name"); // "张三"
map.has("title"); // true
map.get("title"); // "Author"
```

如果读取一个未知的键，则返回`undefined`。

```javascript
new Map().get("asfddfsasadf");
// undefined
```

注意，只有对同一个对象的引用，Map 结构才将其视为同一个键。这一点要非常小心。

```javascript
const map = new Map();

map.set(["a"], 555);
map.get(["a"]); // undefined
```

上面代码的`set`和`get`方法，表面是针对同一个键，但实际上这是两个不同的数组实例，内存地址是不一样的，因此`get`方法无法读取该键，返回`undefined`。

同理，同样的值的两个实例，在 Map 结构中被视为两个键。

```javascript
const map = new Map();

const k1 = ["a"];
const k2 = ["a"];

map.set(k1, 111).set(k2, 222);

map.get(k1); // 111
map.get(k2); // 222
```

##### 2、实例的属性和操作方法

**（1）size 属性**

`size`属性返回 Map 结构的成员总数。

```javascript
const map = new Map();
map.set("foo", true);
map.set("bar", false);

map.size; // 2
```

**（2）Map.prototype.set(key, value)**

`set`方法设置键名`key`对应的键值为`value`，然后返回整个 Map 结构。如果`key`已经有值，则键值会被更新，否则就新生成该键。

```javascript
const m = new Map();

m.set("edition", 6); // 键是字符串
m.set(262, "standard"); // 键是数值
m.set(undefined, "nah"); // 键是 undefined
```

`set`方法返回的是当前的`Map`对象，因此可以采用链式写法。

```javascript
let map = new Map().set(1, "a").set(2, "b").set(3, "c");
```

**（3）Map.prototype.get(key)**

`get`方法读取`key`对应的键值，如果找不到`key`，返回`undefined`。

```javascript
const m = new Map();

const hello = function () {
  console.log("hello");
};
m.set(hello, "Hello ES6!"); // 键是函数

m.get(hello); // Hello ES6!
```

**（4）Map.prototype.has(key)**

`has`方法返回一个布尔值，表示某个键是否在当前 Map 对象之中。

```javascript
const m = new Map();

m.set("edition", 6);
m.set(262, "standard");
m.set(undefined, "nah");

m.has("edition"); // true
m.has("years"); // false
m.has(262); // true
m.has(undefined); // true
```

**（5）Map.prototype.delete(key)**

`delete`方法删除某个键，返回`true`。如果删除失败，返回`false`。

```javascript
const m = new Map();
m.set(undefined, "nah");
m.has(undefined); // true

m.delete(undefined);
m.has(undefined); // false
```

**（6）Map.prototype.clear()**

`clear`方法清除所有成员，没有返回值。

```javascript
let map = new Map();
map.set("foo", true);
map.set("bar", false);

map.size; // 2
map.clear();
map.size; // 0
```

**（1）size 属性**

`size`属性返回 Map 结构的成员总数。

```javascript
const map = new Map();
map.set("foo", true);
map.set("bar", false);

map.size; // 2
```

**（2）Map.prototype.set(key, value)**

`set`方法设置键名`key`对应的键值为`value`，然后返回整个 Map 结构。如果`key`已经有值，则键值会被更新，否则就新生成该键。

```javascript
const m = new Map();

m.set("edition", 6); // 键是字符串
m.set(262, "standard"); // 键是数值
m.set(undefined, "nah"); // 键是 undefined
```

`set`方法返回的是当前的`Map`对象，因此可以采用链式写法。

```javascript
let map = new Map().set(1, "a").set(2, "b").set(3, "c");
```

**（3）Map.prototype.get(key)**

`get`方法读取`key`对应的键值，如果找不到`key`，返回`undefined`。

```javascript
const m = new Map();

const hello = function () {
  console.log("hello");
};
m.set(hello, "Hello ES6!"); // 键是函数

m.get(hello); // Hello ES6!
```

**（4）Map.prototype.has(key)**

`has`方法返回一个布尔值，表示某个键是否在当前 Map 对象之中。

```javascript
const m = new Map();

m.set("edition", 6);
m.set(262, "standard");
m.set(undefined, "nah");

m.has("edition"); // true
m.has("years"); // false
m.has(262); // true
m.has(undefined); // true
```

**（5）Map.prototype.delete(key)**

`delete`方法删除某个键，返回`true`。如果删除失败，返回`false`。

```javascript
const m = new Map();
m.set(undefined, "nah");
m.has(undefined); // true

m.delete(undefined);
m.has(undefined); // false
```

**（6）Map.prototype.clear()**

`clear`方法清除所有成员，没有返回值。

```javascript
let map = new Map();
map.set("foo", true);
map.set("bar", false);

map.size; // 2
map.clear();
map.size; // 0
```

**（1）size 属性**

`size`属性返回 Map 结构的成员总数。

```javascript
const map = new Map();
map.set("foo", true);
map.set("bar", false);

map.size; // 2
```

**（2）Map.prototype.set(key, value)**

`set`方法设置键名`key`对应的键值为`value`，然后返回整个 Map 结构。如果`key`已经有值，则键值会被更新，否则就新生成该键。

```javascript
const m = new Map();

m.set("edition", 6); // 键是字符串
m.set(262, "standard"); // 键是数值
m.set(undefined, "nah"); // 键是 undefined
```

`set`方法返回的是当前的`Map`对象，因此可以采用链式写法。

```javascript
let map = new Map().set(1, "a").set(2, "b").set(3, "c");
```

**（3）Map.prototype.get(key)**

`get`方法读取`key`对应的键值，如果找不到`key`，返回`undefined`。

```javascript
const m = new Map();

const hello = function () {
  console.log("hello");
};
m.set(hello, "Hello ES6!"); // 键是函数

m.get(hello); // Hello ES6!
```

**（4）Map.prototype.has(key)**

`has`方法返回一个布尔值，表示某个键是否在当前 Map 对象之中。

```javascript
const m = new Map();

m.set("edition", 6);
m.set(262, "standard");
m.set(undefined, "nah");

m.has("edition"); // true
m.has("years"); // false
m.has(262); // true
m.has(undefined); // true
```

**（5）Map.prototype.delete(key)**

`delete`方法删除某个键，返回`true`。如果删除失败，返回`false`。

```javascript
const m = new Map();
m.set(undefined, "nah");
m.has(undefined); // true

m.delete(undefined);
m.has(undefined); // false
```

**（6）Map.prototype.clear()**

`clear`方法清除所有成员，没有返回值。

```javascript
let map = new Map();
map.set("foo", true);
map.set("bar", false);

map.size; // 2
map.clear();
map.size; // 0
```

##### 3、遍历方法

Map 结构原生提供三个遍历器生成函数和一个遍历方法。

- `Map.prototype.keys()`：返回键名的遍历器。
- `Map.prototype.values()`：返回键值的遍历器。
- `Map.prototype.entries()`：返回所有成员的遍历器。
- `Map.prototype.forEach()`：遍历 Map 的所有成员。

需要特别注意的是，Map 的遍历顺序就是插入顺序。

```javascript
// 遍历方法
const m2 = new Map().set("a", 1).set("b", 2).set("c", 3);
for (const item of m2.keys()) {
  console.log(item); // a,b,c
}
for (const item of m2.values()) {
  console.log(item); // 1,2,3
}
for (const item of m2.entries()) {
  console.log(item); // ["a", 1]["b", 2] ["c", 3]
}
```

Map 结构转为数组结构，比较快速的方法是使用扩展运算符（`...`）。

```javascript
const map = new Map([
  [1, 'one'],
  [2, 'two'],
  [3, 'three'],
]);

[...map.keys()]
// [1, 2, 3]

[...map.values()]
// ['one', 'two', 'three']

[...map.entries()]
// [[1,'one'], [2, 'two'], [3, 'three']]

[...map]
// [[1,'one'], [2, 'two'], [3, 'three']]
```

##### 4、与其他数据结构的互相转换

**（1）Map 转为数组**

前面已经提过，Map 转为数组最方便的方法，就是使用扩展运算符（`...`）。

```javascript
const myMap = new Map().set(true, 7).set({ foo: 3 }, ["abc"]);
[...myMap];
// [ [ true, 7 ], [ { foo: 3 }, [ 'abc' ] ] ]
```

**（2）数组 转为 Map**

将数组传入 Map 构造函数，就可以转为 Map。

```javascript
new Map([
  [true, 7],
  [{ foo: 3 }, ["abc"]],
]);
// Map {
//   true => 7,
//   Object {foo: 3} => ['abc']
// }
```

**（3）Map 转为对象**

如果所有 Map 的键都是字符串，它可以无损地转为对象。

```javascript
function strMapToObj(strMap) {
  let obj = Object.create(null);
  for (let [k, v] of strMap) {
    obj[k] = v;
  }
  return obj;
}

const myMap = new Map().set("yes", true).set("no", false);
strMapToObj(myMap);
// { yes: true, no: false }
```

如果有非字符串的键名，那么这个键名会被转成字符串，再作为对象的键名。

**（4）对象转为 Map**

对象转为 Map 可以通过`Object.entries()`。

```javascript
let obj = { a: 1, b: 2 };
let map = new Map(Object.entries(obj));
```

##### 5、算法题解析

###### [349. 两个数组的交集](https://leetcode-cn.com/problems/intersection-of-two-arrays/)

![img](https://img-blog.csdnimg.cn/20210614103333685.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1dlYl9TdHJ1Z2dsZQ==,size_16,color_FFFFFF,t_70)

```js
//  Map解题
var intersection = function (nums1, nums2) {
  const map = new Map();
  nums1.forEach(item => {
    map.set(item, true)
  })
  const res = [];
  nums2.forEach(item => {
    if (map.get(item)) {
      res.push(item)
      map.delete(item)
    }
  })
  return res;
};
```

###### [20. 有效的括号](https://leetcode-cn.com/problems/valid-parentheses/)

```js
/**
 * @param {string} s
 * @return {boolean}
 */
var isValid = function(s) {
    if(s.length % 2 == 1) {return false}
    const stack = [];
    const map = new Map();
    map.set('(',')')
    map.set('[',']')
    map.set('{','}')
    for(let i = 0; i < s.length; i++) {
        const t = s[i];
        if(map.get(t)) {
            stack.push(t) // 入栈
        }else {
            const top = stack[stack.length - 1] // 获取栈顶元素
            if(t === map.get(top)) {
                stack.pop();
            }else {
                return false
            }
        }
    }
    return stack.length === 0;
};
```

###### [1. 两数之和](https://leetcode-cn.com/problems/two-sum/)

```js
/**
 * @param {number[]} nums
 * @param {number} target
 * @return {number[]}
 */
var twoSum = function(nums, target) {
    const map = new Map();
    if(nums.length) {
        for(let i = 0;i < nums.length; i++) {
            const n1 = nums[i]
            const n2 = target - n1 // target = 两个整数之和
            if(map.has(n2)) {
                return [map.get(n2),i]
            }else {
                map.set(n1,i)
            }
        }
    }
};
```

###### [3. 无重复字符的最长子串](https://leetcode-cn.com/problems/longest-substring-without-repeating-characters/)

```js
/**
 * @param {string} s
 * @return {number}
 */
var lengthOfLongestSubstring = function(s) {
    let l = 0; // 左指针的初始位置
    let res = 0; // 长度初始值为0
    const map = new Map();
    for(let r = 0; r < s.length; r++) {
        if(map.has(s[r]) && map.get(s[r]) >= l ) {
            l = map.get(s[r]) + 1;
        }
        res = Math.max(res, r - l + 1);
        map.set(s[r], r);
    }
    return res;
};
```

#### 10、树

- 一种分层数据的抽象模型
- 前端工作常见的树：`DOM`树，级联选择器，树形控件等。
- `JS`没有树，可以用`Object`和`Array`构建树。

```js
// 树的模型
{
    value:'gd',
    id:19,
    children:[
        {
            value:'gz',
    		id:2344,
            children:[
                {
                    value:'ht',
                    id:36888,
                }
            ]
        }
    ]
}
```

- 树的常用操作：深度、广度优先遍历，先中后序遍历

##### 10-1深度、广度优先遍历

![img](https://img-blog.csdnimg.cn/20210614165532518.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1dlYl9TdHJ1Z2dsZQ==,size_16,color_FFFFFF,t_70)

**可以这么理解：深度优先遍历表示从头一页一页的看一本书，而广度优先遍历表示：先看书的目录。再深入了解书的章节**

##### 10-2深度优先遍历的算法口诀

1. 访问根节点
2. 对根节点的`children`挨个进行深度优先遍历(即递归)

**代码实现**

```js
const tree = {
  val: 'a',
  children: [{
    val: 'b',
    children: [{
      val: 'd',
      children: [],
    }, {
      val: 'e',
      children: [],
    }],
  }, {
    val: 'c',
    children: [{
      val: 'f',
      children: [],
    }, {
      val: 'g',
      children: [],
    }],
  }],
}
const dfs = (root) => {
  console.log(root.val);
  root.children.forEach(dfs) // 采用递归调用
}
dfs(tree); // a,b,d,e,c,f,g
```

##### 10-3广度优先遍历的算法口诀

![img](https://img-blog.csdnimg.cn/20210614172458836.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1dlYl9TdHJ1Z2dsZQ==,size_16,color_FFFFFF,t_70)

1. 新建一个队列，把根节点挨个入队
2. 把对头出队，进行访问
3. 把对头的`children`挨个入队
4. 重复2,3的步骤，直到队列为空

```js
const tree = {
  val: 'a',
  children: [{
    val: 'b',
    children: [{
      val: 'd',
      children: [],
    }, {
      val: 'e',
      children: [],
    }],
  }, {
    val: 'c',
    children: [{
      val: 'g',
      children: [],
    }, {
      val: 'f',
      children: [],
    }],
  }],
}
const bfs = (root) => {
  const q = [root]
  while (q.length > 0) {
    const n = q.shift(); // 对头出队
    console.log(n.val)
    n.children.forEach(item => { // 把对头的`children`挨个入队
      q.push(item)
    })
  }
}
bfs(tree) // a,b,c,d,e,f,g
```

##### 10-4二叉树

1. 树中的节点最多只能有两个字节点
2. 在`JS`中通常用`Object`来模拟二叉树

**二叉树模型**

```js
{
    val:'1',
    left:{
        val:'2',
        left:null,
        right:null
    },
    right:{
       val:'3',
       left:null,
       right:null
    }
}
```

###### 10-4-1二叉树，先序遍历算法口诀

![img](https://img-blog.csdnimg.cn/20210614174924117.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1dlYl9TdHJ1Z2dsZQ==,size_16,color_FFFFFF,t_70)

**代码实现**

```js
const bt = {
  val: '1',
  left: {
    val: '2',
    left: {
      val: '4',
      left: null,
      right: null
    },
    right: {
      val: '5',
      left: null,
      right: null
    }
  },
  right: {
    val: '3',
    left: {
      val: '6',
      left: null,
      right: null
    },
    right: {
      val: '7',
      left: null,
      right: null
    }
  }
}
// (递归版)
const preorder = (root) => {
  if (!root) {
    return false
  }
  console.log(root.val) // 1,2,4,5,3,6,7
  preorder(root.left) // 对根节点的左子树进行先序遍历。
  preorder(root.right) // 对根节点的右子树进行先序遍历。
}
preorder(bt)
/**
 * 非递归
 * 由于先访问根节点，可以看做栈来操作
 */
const preorder = (root) => {
  if (!root) {
    return false
  }
  const stack = [root];
  while (stack.length) {
    const n = stack.pop(); // 先访问栈顶元素，即根节点
    console.log(n.val); // 1,2,4,5,3,6,7
    // 根据后进先出，先操作右子树进行先序遍历
    if (n.right) stack.push(n.right)
    if (n.left) stack.push(n.left)
  }
}
preorder(bt)

```

###### 10-4-2二叉树，中序遍历算法口诀

![img](https://img-blog.csdnimg.cn/20210614201747160.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1dlYl9TdHJ1Z2dsZQ==,size_16,color_FFFFFF,t_70)

**代码实现**

```js
const bt = require('./bt.js')
// 递归
const inorder = (root) => {
  if (!root) {
    return false
  }
  inorder(root.left) // 对根节点的左子树进行中序遍历。
  console.log(root.val) // 4,2,5,1,6,3,7
  inorder(root.right) // 对根节点的右子树进行中序遍历。
}
inorder(bt)
/**
 * 非递归
 */
const inorder = (root) => {
  if (!root) {
    return false
  }
  const stack = [];
  let p = root;
  while (stack.length || p) {
    while (p) {
      stack.push(p);
      p = p.left
    }
    const n = stack.pop();
    console.log(n.val); // 4,2,5,1,6,3,7
    p = n.right
  }
}
inorder(bt)
```

###### 10-4-2二叉树，后序遍历算法口诀

![img](https://img-blog.csdnimg.cn/20210614202413317.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1dlYl9TdHJ1Z2dsZQ==,size_16,color_FFFFFF,t_70)

**代码实现**

```js
const bt = require('./bt.js')
// 递归版
const mdorder = (root) => {
  if (!root) {
    return false
  }
  mdorder(root.left) // 对根节点的左子树进行中序遍历。
  mdorder(root.right) // 对根节点的右子树进行中序遍历。
  console.log(root.val) // 4,5,2,6,7,3,1
}
mdorder(bt)
// 非递归
const mdorder = (root) => {
  if (!root) {
    return false
  }
  const stack = [root];
  const outPutStack = [];
  while (stack.length) {
    const n = stack.pop(); // 先访问栈顶元素，即根节点
    outPutStack.push(n) // 存入到逆向输出的数组里
    if (n.left) stack.push(n.left)
    if (n.right) stack.push(n.right)
  }
  while (outPutStack.length) {
    const n = outPutStack.pop();
    console.log(n.val); // 4,5,2,6,7,3,1
  }
}
mdorder(bt)
```

##### 10-5算法题解析

###### [104. 二叉树的最大深度](https://leetcode-cn.com/problems/maximum-depth-of-binary-tree/)

![img](https://img-blog.csdnimg.cn/20210614233201431.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1dlYl9TdHJ1Z2dsZQ==,size_16,color_FFFFFF,t_70)

```js
var maxDepth = function(root) {
    let res = 0 ;
    const dfs = (item,l) => {
        if(!item) {return false;}
        if(!item.left && !item.right) {
            res = Math.max(res, l)
        }
        dfs(item.left,l+1)
        dfs(item.right,l+1)
    }
    dfs(root,1)
    return res
};
```



###### [111. 二叉树的最小深度](https://leetcode-cn.com/problems/minimum-depth-of-binary-tree/)

![img](https://img-blog.csdnimg.cn/20210615165112814.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1dlYl9TdHJ1Z2dsZQ==,size_16,color_FFFFFF,t_70)

```js
/**
 * @param {TreeNode} root
 * @return {number}
 */
var minDepth = function(root) {
    if (!root) {
            return 0;
        }
        const q = [[root,1]]
        while(q.length) {
             const [n,l] = q.shift();
             if(!n.left && !n.right) {
                 return l;
             }
             if(n.left) q.push([n.left, l+ 1])
             if(n.right) q.push([n.right, l+ 1])
        } 
};
```

###### [102. 二叉树的层序遍历](https://leetcode-cn.com/problems/binary-tree-level-order-traversal/)

```js
/**
 * @param {TreeNode} root
 * @return {number[][]}
 */
var levelOrder = function(root) {
    if(!root) {return [];}
    const q = [[root,0]];
    let res = [];
    while(q.length) {
        const [n,leave] = q.shift();
        if(!res[leave]) { // 层级为0 的时候，根节点入队
            res.push([n.val])
        }else {
            res[leave].push(n.val) // 根据层级添加对应的val值
        }
        console.log(n.val,leave)
        if(n.left) q.push([n.left,leave+1]);
        if(n.right) q.push([n.right,leave+1]);
    }
    return res;
};
```

###### [94. 二叉树的中序遍历](https://leetcode-cn.com/problems/binary-tree-inorder-traversal/)

```js
/**
 * @param {TreeNode} root
 * @return {number[]}
 * 二叉树中序遍历
 */
var inorderTraversal = function(root) {
    if(!root) {return [];}
        const stack = [];
        const res =[];
        let p = root;
        while(stack.length || p) {
            while(p) {
            stack.push(p);
            p = p.left;
        }
            const n = stack.pop();
            res.push(n.val)
            p = n.right;
        }
        return res;
};
```

###### [112. 路径总和](https://leetcode-cn.com/problems/path-sum/)

![img](https://img-blog.csdnimg.cn/20210615165143405.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1dlYl9TdHJ1Z2dsZQ==,size_16,color_FFFFFF,t_70)

```js
/**
 * @param {TreeNode} root
 * @param {number} targetSum
 * @return {boolean}
 */
var hasPathSum = function(root, targetSum) {
    if(!root) {return false;}
    let res = false;
    const dfs = (n,sum) => {
        // 深度优先遍历
        console.log(n.val,sum);
        if(!n.left && !n.right && sum == targetSum) {
            res = true;
        }
        if(n.left) dfs(n.left,sum + n.left.val);
        if(n.right) dfs(n.right,sum + n.right.val);
    }
    dfs(root,root.val)
    return res;
};
```



#### 11、图

##### 11-1图是什么？

- 图是网络结构的抽象模型，是一-组由边连接的节点。

- 图可以表示任何二元关系，比如道路、航班。
- JS中没有图,但是可以用`Object`和`Array`构建图。
- 图的表示法:邻接矩阵、邻接表、关联矩....

![img](https://img-blog.csdnimg.cn/20210616170859945.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1dlYl9TdHJ1Z2dsZQ==,size_16,color_FFFFFF,t_70)

**如果节点A能连接到节点B，那么矩阵B对应的行或者列表示为1，否则为0**

![img](https://img-blog.csdnimg.cn/20210616171155367.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1dlYl9TdHJ1Z2dsZQ==,size_16,color_FFFFFF,t_70)

**节点A能连接到节点B，那么A：["B"]，这个比较好理解的。**

图的常用操作

- 深度优先遍历
- 广度优先遍历

##### 11-2图的深度优先遍历算法口诀

1. 访问根节点。
2. 对根节点的**没访问过的相邻节点**挨个进行深度优先遍历。

![img](https://img-blog.csdnimg.cn/20210616173150909.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1dlYl9TdHJ1Z2dsZQ==,size_16,color_FFFFFF,t_70)

**没访问过的相邻节点**：如上图所示，如果从节点2开始遍历，优先遍历节点0,节点0在返回到节点2就会造成死循环，如果加个没访问过的相邻节点判断，就会寻找下个非访问过的节点了。

**代码实现**

```js
// graph.js
const graph = {
  0:[1,2],
  1:[2],
  2:[0,3],
  3:[3]
}
module.exports = graph;
// dfs.js
const graph = require('./graph');
// 声明一个集合，记录已遍历过的节点
const isVistive = new Set();
const dfs =(n) => {
  console.log(n); // 2,0,1,3
  isVistive.add(n); // 记录已遍历过的节点
  graph[n].forEach(item => {
    if(!isVistive.has(item)) {
      dfs(item)
    }
  })
}
dfs(2);
```



##### 11-3图的广度优先遍历算法口诀

1. 新建一个队列，把根节点入队。
2. 把队头出队并访问。
3. 把队头的没访问过的相邻节点入队。
4. 重复第二、三步，直到队列为空。

**代码实现**

```js
const graph = require('./graph');
// 声明一个集合，记录已遍历过的节点
const isVistive = new Set();
isVistive.add(2) // 先把初始节点添加到集合
const bfs = () => {
  const q = [2];
  while (q.length) {
    const n = q.shift();
    console.log(n);// 2,0,3,1
    graph[n].forEach(item => {
      if (!isVistive.has(item)) {
        q.push(item)
        isVistive.add(item);
      }
    })
  }
}
bfs();
```

##### 11-4 算法题

###### [65. 有效数字](https://leetcode-cn.com/problems/valid-number/)

![img](https://img-blog.csdnimg.cn/20210616224907300.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1dlYl9TdHJ1Z2dsZQ==,size_16,color_FFFFFF,t_70)

**图片描述**：  编号1，开始走节点6的位置，最终停留在节点6，所以0是有效数字。编号3，a开头无路可走，所以编号3是无效数字。只有遍历到节点3、5、6的时候，数字才是有效数字。

**解题步骤**

1. 构建一个表示状态的图。
2. 遍历字符串，并沿着图走，如果到了某个节点无路可走就返false
3. 遍历结束，如走到3/5/6，就返回true，否则返回false。

```js
/**
 * @param {string} s
 * @return {boolean}
 */
var isNumber = function(s) {
    const graph = {
        0:{'blank':0,'digit':6,'sign':1,'.':2},
        1:{'digit':6, '.':2},
        2:{'digit':3},
        3:{'digit':3, 'e':4},
        4:{'digit':5,'sign':7},
        5:{'digit':5},
        6:{'digit':6, '.':3, 'e':4},
        7:{'digit':5}
    }
    let state = 0; // 初始状态值为0；
    for(item of s.trim()) {
        if(item >= '0' && item <= '9') {
            item = 'digit'
        }else if(item === '') {
            item = 'blank'
        }else if(item === '+' || item === '-') {
            item = 'sign'
        }else if(item === 'e' || item === 'E') {
            item = 'e'
        }
        state = graph[state][item]
        if(state == undefined) {
            return false;
        }
    }
    if(state == 3 || state == 6 || state == 5) {
        return true;
    }
    return false;
};
```



###### [417. 太平洋大西洋水流问题](https://leetcode-cn.com/problems/pacific-atlantic-water-flow/)

```shell
给定下面的 5x5 矩阵:
  太平洋 ~   ~   ~   ~   ~ 
       ~  1   2   2   3  (5) *
       ~  3   2   3  (4) (4) *
       ~  2   4  (5)  3   1  *
       ~ (6) (7)  1   4   5  *
       ~ (5)  1   1   2   4  *
          *   *   *   *   * 大西洋
```

**解题步骤**

1. 新建两个矩阵,分别记录能流到两个大洋的坐标。
2. 从海岸线,多管齐下，同时深度优先遍历图,过程中填充上述矩阵。
3. 遍历两个矩阵，找出能流到两个大洋的坐标。

```js
/**
 * @param {number[][]} heights
 * @return {number[][]}
 */
var pacificAtlantic = function (heights) {
    if (!heights || !heights[0] || !heights[0].length) return []
    const m = heights.length
    const n = heights[0].length
    // 逆流而上，走出一条通道
    // 存放太平洋->大西洋的路径
    const flow1 = Array.from({ length: m }, () => {
        return Array.from({ length: n }, () => false)
    })
    // 存放大西洋->太平洋的路径
    const flow2 = Array.from({ length: m }, () => {
        return Array.from({ length: n }, () => false)
    })
    const dfs = (r, c, flow) => {
        flow[r][c] = true;
        [[r - 1, c], [r, c + 1], [r + 1, c], [r, c - 1]].forEach(([nr, nc]) => {
            if (nr >= 0 && nr < m &&
                nc >= 0 && nc < n &&
                !flow[nr][nc] &&
                heights[nr][nc] >= heights[r][c]
            ) {
                dfs(nr, nc, flow)
            }
        })
    }
    //多管齐下, 第一行遍历到最后行，第一列遍历到最后列
    for (let i = 0; i < m; i++) {
        dfs(i, 0, flow1)
        dfs(i, n - 1, flow2)
    }
    for (let i = 0; i < n; i++) {
        dfs(0, i, flow1)
        dfs(m - 1, i, flow2)
    }
    // 找出两条路都能走通的节点
    const res = []
    for (let i = 0; i < m; i++) {
        for (let j = 0; j < n; j++) {
            if (flow1[i][j] && flow2[i][j]) {
                res.push([i, j])
            }
        }
    }
    return res
};
```

###### [133. 克隆图](https://leetcode-cn.com/problems/clone-graph/)

#### 12、堆

##### 12-1堆是什么？

![img](https://img-blog.csdnimg.cn/20210618180204299.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1dlYl9TdHJ1Z2dsZQ==,size_16,color_FFFFFF,t_70)



![img](https://img-blog.csdnimg.cn/20210618180240393.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1dlYl9TdHJ1Z2dsZQ==,size_16,color_FFFFFF,t_70)

**上图解释**：index指的是数组的下标索引。

##### 12-2堆的应用

- 堆能高效、快速地找出最大值和最小值，时间复杂度: 0(1)。
- 找出第K个最大(小)元素。

**找出第K个最大元素**

![img](https://img-blog.csdnimg.cn/20210618180330980.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1dlYl9TdHJ1Z2dsZQ==,size_16,color_FFFFFF,t_70)

1. 构建一个最小堆，并将元素依次插入堆中。
2. 当堆的容量超过K,就删除堆顶。
3. 插入结束后，堆顶就是第K个最大元素。

**实现最小堆类**

实现步骤：

1. 在类里，声明-一个数组，用来装元素。
2. 主要方法:插入、删除堆顶、获取堆顶、获取堆大小。

##### **插入方法**

1. 将值插入堆的底部，即数组的尾部。
2. 然后上移:将这个值和它的父节点进行交换，直到父节点小于等于这个插入的值。
3. 大小为k的堆中插入元素的时间复杂度为O(logk)。

**代码实现**

```js
// 插入方法，获取第K个最小元素
class MinHeap {
  constructor() {
    this.heap = [];
  }
  // 交换函数
  swap(i1,i2){
    let temp = this.heap[i1]
    this.heap[i1] = this.heap[i2]
    this.heap[i2] = temp;
  }
  // 获取父节点的位置  (index -1 ) / 2 的余数
  getParentIndex(i) {
    return (i - 1) >> 1
  }
  // 上移操作:将这个值和它的父节点进行交换，直到父节点小于等于这个插入的值。
  shiftUp(index){
    // index == 0 到栈顶了， 就返回
    if(index == 0) {return;}
    const parentIndex = this.getParentIndex(index);
    // 和父节点交换
    if(this.heap[parentIndex] > this.heap[index]) {
      this.swap(parentIndex,index)
      this.shiftUp(parentIndex)
    }
  }
  // 将值插入堆的底部
  insert(value) {
    this.heap.push(value)
    this.shiftUp(this.heap.length - 1)
  }
}
const h = new MinHeap();

h.insert(3)
h.insert(2)
h.insert(1)
```

##### **删除堆顶**

1. 用数组尾部元素替换堆顶(直接删除堆顶会破坏堆结构)。
2. 然后下移:将新堆顶和它的子节点进行交换，直到子节点大于等于这个新堆顶。
3. 大小为k的堆中删除堆顶的时间复杂度为O(logk)。

**代码实现**

```js
// 插入方法，获取第K个最小元素
class MinHeap {
  constructor() {
    this.heap = [];
  }
  // 交换函数
  swap(i1,i2){
    let temp = this.heap[i1]
    this.heap[i1] = this.heap[i2]
    this.heap[i2] = temp;
  }
  // 获取父节点的位置  (index -1 ) / 2 的余数
  getParentIndex(i) {
    return (i - 1) >> 1
  }
  // 获取左节点的位置 index * 2 + 1
  getLeftIndex(i) {
    return i * 2 + 1;
  }
  // 获取右节点的位置 index * 2 + 2
  getRightIndex(i) {
    return i * 2 + 2;
  }
  // 上移操作:将这个值和它的父节点进行交换，直到父节点小于等于这个插入的值。
  shiftUp(index){
    // index == 0 到栈顶了， 就返回
    if(index == 0) {return;}
    const parentIndex = this.getParentIndex(index);
    // 和父节点交换
    if(this.heap[parentIndex] > this.heap[index]) {
      this.swap(parentIndex,index)
      this.shiftUp(parentIndex)
    }
  }
  // 下移，将新堆顶和它的子节点进行交换，直到子节点大于等于这个新堆顶。
  shiftDown(index) {
    const leftIndex = this.getLeftIndex(index);
    const rightIndex = this.getRightIndex(index);
    if(this.heap[leftIndex] < index) {
      this.swap(leftIndex,index)
      this.shiftDown(leftIndex);
    }
    if(this.heap[rightIndex] < index) {
      this.swap(rightIndex,index)
      this.shiftDown(rightIndex);
    }
  }
  // 将值插入堆的底部
  insert(value) {
    this.heap.push(value)
    this.shiftUp(this.heap.length - 1)
  }
  pop() {
    this.heap[0] = this.heap.pop(); // 用数组尾部元素替换堆顶
    this.shiftDown(0)
  }
}
const h = new MinHeap();

h.insert(3)
h.insert(2)
h.insert(1)
h.pop();
```

##### **获取堆顶和堆的大小**

#### 13、进阶算法-搜索排序

#### 14、 算法思想之“分而治之”

#### 15、 算法思想之“动态规划”

#### 16、 算法思想之“贪心算法”

#### 17、 算法思想之“回溯算法”

#### 18、 算法思想之“图论”
