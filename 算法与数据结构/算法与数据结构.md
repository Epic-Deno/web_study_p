# 前端算法与数据结构

[leetcode 官方网址](https://leetcode-cn.com/)

#### 1、算法和数据结构含义

- 数据结构：计算机存储，组织数据的方式
- 算法：一系列解决问题的清晰指令

##### 1-1 关系

- 程序 = 数据结构 + 算法
- 数据结构为算法提供服务，算法围绕数据结构进行操作

##### 1-2 数据结构

- 栈、队列、链表（有序）
- 集合、字典（无序）
- 树、堆、图（有一定连接关系）

##### 1-3 算法

- 链表：遍历链表、删除节点链表
- 树、图：深度/广度优先遍历
- 数组：冒泡/选择/插入/快速排序等等

#### 2、leetcode 的介绍

##### 2-1 功能

- 题库、社区、竞赛、模拟刷题

![1620272226001](https://7775-wujianfeng-6g8spsvm7152bed9-1258453358.tcb.qcloud.la/typora-user-images/1620272226001.png)

![1620272326589](https://7775-wujianfeng-6g8spsvm7152bed9-1258453358.tcb.qcloud.la/typora-user-images/1620272326589.png)

- 做题
  - 查看题目描述，评论，题解，提交记录
  - ![1620272463634](https://7775-wujianfeng-6g8spsvm7152bed9-1258453358.tcb.qcloud.la/typora-user-images/1620272463634.png)

#### 3、时间复杂度

- 一个函数，用大写 O 来表示，比如：O(1)、O(n)、O(n^2)...等等

![图解](https://bkimg.cdn.bcebos.com/pic/dcc451da81cb39db86d6cf67dd160924ab1830e8?x-bce-process=image/watermark,image_d2F0ZXIvYmFpa2U4MA==,g_7,xp_5,yp_5/format,f_auto)

- 时间复杂度为 O(1)

```js
let i = 0;
i = i + 1;
```

- 时间复杂度为 O(n)

```js
for (let i = 0; i < n; i++) {
  console.log(i);
}
// 在一个for循环体里面，这个循环做了n次
```

- 时间复杂度为：O(n) + O(1) = O(n)

```javascript
let i = 0;
i = i + 1;
for (let i = 0; i < n; i++) {
  console.log(i);
}
```

- 时间复杂度为：O(n) \* O(n) = O(n^2)

```javascript
for (let i = 0; i < n; i++) {
  for (let j = 0; j < n; j++) {
    console.log(i, j);
  }
}
```

- 时间复杂度为：O(logN)

```javascript
let i = 1;
while (i < n) {
  console.log(i);
  i *= 2;
}
// 如果a^x =N（a>0，且a≠1），那么数x叫做以a为底N的对数，记作x=logaN
```

#### 4、空间复杂度

- 一个函数，用大写 O 来表示，比如：O(1)、O(n)、O(n^2)...等等
- 算法在运行过程中临时占用存储大小的量度。_你写的代码占用的空间大小_

- 空间复杂度为 O(1)

```javascript
let i = 0;
i = i + 1;
```

- 空间复杂度为 O(n)

```javascript
let arr = [];
for (let i = 0; i < n; i++) {
  arr.push(i);
}
```

- 空间复杂度为：O(n^2)

```javascript
let arr = [];
for (let i = 0; i < n; i++) {
  arr.push([]);
  for (let j = 0; j < n; j++) {
    arr[i].push(j);
  }
}
// 矩阵，本质二维数组
```

#### 5、栈

##### 5-1 栈简介

- 栈是一个后进先出的数据结构

![1620283277523](https://7775-wujianfeng-6g8spsvm7152bed9-1258453358.tcb.qcloud.la/typora-user-images/1620283277523.png)

- JavaScript 中没有栈，可以用 Array 数组实现栈的所有功能
  - 代码实现，定义一个 stack 的空数组，在 push 方法打上断点，按 F5，编辑器自带的 js 调试，点击箭头执行下一步操作，左边控制面板可以看出：先入栈的元素是‘a’，先出栈的元素是'd'，满足后进先出原则。
- 栈常用操作：push、pop、stack[stack.length - 1]

![1620298107492](https://7775-wujianfeng-6g8spsvm7152bed9-1258453358.tcb.qcloud.la/typora-user-images/1620298107492.png)

![1620298169848](https://7775-wujianfeng-6g8spsvm7152bed9-1258453358.tcb.qcloud.la/typora-user-images/1620298169848.png)

##### 5-2 栈应用

- 十进制转二进制

  - 倒叙写二进制

  ![1620289310238](https://7775-wujianfeng-6g8spsvm7152bed9-1258453358.tcb.qcloud.la/typora-user-images/1620289310238.png)

- 判断字符串的括号是否有效

  - 越靠后的左括号，对应的右括号越靠前。
  - 从左到右遍历括号，遇到左括号入栈，遇到右括号出栈，最后栈空了就是合法的。

  ![1620289355548](https://7775-wujianfeng-6g8spsvm7152bed9-1258453358.tcb.qcloud.la/typora-user-images/1620289355548.png)

- 函数调用堆栈

  - 最后调用的函数，最先执行完。
  - JS 解释器使用栈来控制函数的调用顺序

```javascript
function run() {
  console.log("1");
  sayHello();
  console.log("2");
}
function sayHello() {
  console.log("hello");
}
run();
// 1
// hello
// 2
```

##### 5-3 栈算法题解析

- 十进制转二进制

```javascript
// num 十进制数字
function get2bin(num) {
  const stack = [];
  while (num > 0) {
    stack.push(num % 2); // 除以2的余数入栈
    num = Math.floor(num / 2); // 获取整除后的结果
  }
  // 定义数组，存放二进制的数
  var arr = [];
  while (stack.length > 0) {
    arr.push(stack.pop());
  }
  console.log(arr);
  return arr.join("");
}
get2bin(35); // 1, 0, 0, 0, 1, 1
```

- #### [20. 有效的括号](https://leetcode-cn.com/problems/valid-parentheses/)

- 对于没有闭合的左括号而言，越靠后的左括号，对应的右括号就越靠前

- 满足后进先出，考虑用栈解决。

- 解题步骤

  - 1、新建一个栈
  - 2、循环字符串，遇到左括号入栈，遇到右括号出栈，遇到类型不匹配判定为不合法。
  - 3、最后栈空了就合法

  ```javascript
  var isValid = function (s) {
    const stack = []; // 新建一个栈
    if (s.length % 2 == 1) {
      return false; // 奇数的长度直接不合法
    }
    for (let i = 0; i < s.length; i++) {
      const val = s[i];
      if (val === "(" || val === "{" || val === "[") {
        stack.push(val); // 判断左括号合法，入栈
      } else {
        const top = stack[stack.length - 1]; // 定义栈顶元素
        if (
          // 栈顶元素的栈底元素匹配
          (top === "(" && val === ")") ||
          (top === "{" && val === "}") ||
          (top === "[" && val === "]")
        ) {
          stack.pop(); // 出栈
        } else {
          return false;
        }
      }
    }
    return stack.length === 0; // 栈空了就合法
  };
  isValid("()");
  isValid("()[]{}");
  isValid("(]");
  isValid("([)]");
  ```

##### 5-4 前端与栈

- 函数的调用（按循序去执行函数）

```javascript
const fn1 = () => {
  fn2();
};
const fn2 = () => {
  fn3();
};
const fn3 = () => {};
fn1();
// 最先执行的函数是fn1 -> fn2 -> fn3
```

- 执行入栈

![1620293610769](https://7775-wujianfeng-6g8spsvm7152bed9-1258453358.tcb.qcloud.la/typora-user-images/1620293610769.png)

- 执行出栈

![1620293713165](https://7775-wujianfeng-6g8spsvm7152bed9-1258453358.tcb.qcloud.la/typora-user-images/1620293713165.png)

#### 6、队列

##### 6-1 队列简介

- 队列是先进先出的数据结构

  ![1620294367021](https://7775-wujianfeng-6g8spsvm7152bed9-1258453358.tcb.qcloud.la/typora-user-images/1620294367021.png)

- JavaScript 中没有队列，可以用 Array 数组实现队列的所有功能

- 入队和出队

- 队列常用操作：push、shift、queue[0]

![1620295210652](https://7775-wujianfeng-6g8spsvm7152bed9-1258453358.tcb.qcloud.la/typora-user-images/1620295210652.png)

![1620295280606](https://7775-wujianfeng-6g8spsvm7152bed9-1258453358.tcb.qcloud.la/typora-user-images/1620295280606.png)

##### 6-2 队列应用

- 排队打饭
- JS 异步中的任务队列
  - JS 是单线程的，无法同时处理异步中的并发任务。
  - 使用队列任务先后处理异步任务
- 计算最近请求次数

##### 6-3 队列算法题解析

- #### [933. 最近的请求次数](https://leetcode-cn.com/problems/number-of-recent-calls/)

- 解题步骤

  - 有新情求就入队，3000ms 前发出的请求出队
  - 队列的长度就是最近的请求次数

  ```javascript
  // 在这个时间 的 过去 3 秒 内, 不停的请求, 求在这个3秒内这个请求了多少下
  var RecentCounter = function () {
    this.queue = [];
  };

  /**
   * @param {number} t
   * @return {number}
   */
  RecentCounter.prototype.ping = function (t) {
    this.queue.push(t);
    // 队头在 t - 3000ms内，出队
    while (this.queue[0] < t - 3000) {
      this.queue.shift();
    }
    return this.queue.length;
  };
  // 时间复杂度：O(n) , 空间复杂度O(n)
  ```

##### 6-4 前端与队列

- Javascript 语言的执行环境是**单线程**的。[js 异步原理解析](https://blog.csdn.net/happyqyt/article/details/90644667)

  所谓"单线程"，就是指一次只能完成一件任务。如果有多个任务，就必须排队，前面一个任务完成，再执行后面一个任务，以此类推。

![1620300436833](https://7775-wujianfeng-6g8spsvm7152bed9-1258453358.tcb.qcloud.la/typora-user-images/1620300436833.png)

#### 7、链表

##### 7-1 链表简介

- 多个元素组成的列表
- 元素存储不连续，用 next 指针连在一起

![1620301104532](https://7775-wujianfeng-6g8spsvm7152bed9-1258453358.tcb.qcloud.la/typora-user-images/1620301104532.png)

- JS 没有链表
- 可以用 Object 模拟链表

![1620301659309](https://7775-wujianfeng-6g8spsvm7152bed9-1258453358.tcb.qcloud.la/typora-user-images/1620301659309.png)

- 遍历链表

  ```javascript
  var a = {
    val: "a",
  };
  var b = {
    val: "b",
  };
  var c = {
    val: "c",
  };
  var d = {
    val: "d",
  };

  a.next = b;
  b.next = c;
  c.next = d;
  // 如此一来，就创建了一个链表
  // 遍历链表

  let p = a;
  while (p) {
    console.log(p.val);
    p = p.next;
  }
  ```

![1620301903085](https://7775-wujianfeng-6g8spsvm7152bed9-1258453358.tcb.qcloud.la/typora-user-images/1620301903085.png)

- 链表插入

  ![1620302297070](https://7775-wujianfeng-6g8spsvm7152bed9-1258453358.tcb.qcloud.la/typora-user-images/1620302297070.png)

  - 链表删除

  ```javascript
  // 删除
  c.next = d; // 把c的next指向d,就能删除e
  ```

##### 7-2 链表算法题解析

- #### [237. 删除链表中的节点](https://leetcode-cn.com/problems/delete-node-in-a-linked-list/)

- 解题思路

  - 无法直接获取被删除节点的上一个元素，将被删除节点的值改成下个节点的值
  - 将被删除节点转移到下个节点（如果想要删除节点 5，先把 5 的节点指向下个元素值，此时链表为 4-1-1-9，再把节点 1 下个元素删除，即可得到 4-1-9 的链表）

  ```javascript
  /**
   * Definition for singly-linked list.
   * function ListNode(val) {
   *     this.val = val;
   *     this.next = null;
   * }
   */
  /**
   * @param {ListNode} node
   * @return {void} Do not return anything, modify node in-place instead.
   */
  var deleteNode = function (node) {
    node = 5;
    node.val = node.next.val;
    node.next = node.next.next;
  };
  ```

  - [206. 反转链表](https://leetcode-cn.com/problems/reverse-linked-list/)

  - [2. 两数相加](https://leetcode-cn.com/problems/add-two-numbers/)

  - [141. 环形链表](https://leetcode-cn.com/problems/linked-list-cycle/)

##### 7-4 前端与链表

###### 7-4-1 JS 原型链含义

- 原型链的本质是链表
- 原型链上的节点是各个原型对象，比如`Function.prototype`、`Object.prototype`
- 原型链通过`__proto__`属性连接各种原型对象

###### 7-4-2 原型链

```javascript
obj -> Object.prototype -> null
fun -> Function.prototype -> Object.prototype -> null
arr -> Array.prototype -> Object.prototype -> null
```

![1620354676155](https://img-blog.csdnimg.cn/20210507112153700.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1dlYl9TdHJ1Z2dsZQ==,size_16,color_FFFFFF,t_70)

###### 7-4-3 原型链知识点

- 如果`A`沿着原型链能找到`B.prototype`，那么`A` `instanceof B` 为 true

```javascript
const obj = {};
const fun = () => {};
const arr = [];
// 对于数组来说，arr即是Array的实例，也是Object的实例
arr instanceof Array; // true
arr instanceof Object; // true
fun instanceof Function; // true
fun instanceof Object; // true
obj instanceof Object; // true
```

- 如果在 A 对象上没有找到 X 属性，那么会沿着原型链找到 X 的属性

```javascript
const obj = {};
obj.name = undefined;
Object.prototype.name = "张三";
obj.name = "张三";
// 函数原型链可以指向Object.prototype
Object.prototype.age = "16";
const fun1 = () => {};
fun1.age = 16;
```

![1620357599056](https://img-blog.csdnimg.cn/20210507112225459.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1dlYl9TdHJ1Z2dsZQ==,size_16,color_FFFFFF,t_70)

![1620358057065](https://img-blog.csdnimg.cn/20210507112748896.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1dlYl9TdHJ1Z2dsZQ==,size_16,color_FFFFFF,t_70)

#### 8、集合

- 集合是一个无序且唯一的数据结构
- ES6 中有集合，Set 数据结构

##### Set 常用方法

```js
// set数据结构常见用法

// 去重

const arr = [1, 1, 2, 3, 4, 5, 3, 4];

const arr2 = [...new Set(arr)]; // [1,2,3,4,5]

// 判断元素是否在集合里

const set = new Set(arr);

const set1 = set.has(1); // true
const set2 = set.has(6); // false

// 求交集

const set3 = new Set([1, 2]);
const el = new Set([...set].filter((item) => set3.has(item))); // [1,2]

// set add方法

const addSet = new Set();
addSet.add(1);
const obj = {
  a: 1,
  b: 2,
};
addSet.add({
  a: 1,
  b: 2,
});
addSet.add(obj); // addSet同时存在两个对象，obj和 {a:1,b:2}两个对象存储的地址不一样
const set4 = addSet.has(obj); // true
const set5 = addSet.has({
  // false
  a: 1,
  b: 2,
});

// delete 删除集合
addSet.delete(1);
addSet.delete(obj);
```

3、遍历操作

Set 结构的实例有四个遍历方法，可以用于遍历成员。

- `Set.prototype.keys()`：返回键名的遍历器
- `Set.prototype.values()`：返回键值的遍历器
- `Set.prototype.entries()`：返回键值对的遍历器
- `Set.prototype.forEach()`：使用回调函数遍历每个成员

需要特别指出的是，`Set`的遍历顺序就是插入顺序。这个特性有时非常有用，比如使用 Set 保存一个回调函数列表，调用时就能保证按照添加顺序调用。

```javascript
// Array.from方法可以将 Set 结构转为数组。
const items = new Set([1, 3, 4, 5, 6, 6, 7, 7]);
console.log(items);
const arr = Array.from(items);
console.log(arr); // [1,3,4,5,7]
// keys返回健明
for (let set of items.keys()) {
  console.log(set); // 1, 3, 4, 5, 6, 7
}
// values返回键值
for (let set of items.values()) {
  console.log(set); // 1, 3, 4, 5, 6, 7
}
// entries方法返回的遍历器，同时包括键名和键值，所以每次输出一个数组，它的两个成员完全相等。
for (let set of items.entries()) {
  console.log(set); // [1, 1] [3, 3] [4, 4] [5, 5] [6, 6] [7, 7]
}
```

Set 结构的实例默认可遍历，它的默认遍历器生成函数就是它的`values`方法。

```javascript
Set.prototype[Symbol.iterator] === Set.prototype.values;
// true
```

这意味着，可以省略`values`方法，直接用`for...of`循环遍历 Set。

```javascript
// 简便写法
const item2 = new Set(["a", "b", "c", "d"]);
for (const set of item2) {
  console.log(set);
}
```

**遍历的应用**

扩展运算符（`...`）内部使用`for...of`循环，所以也可以用于 Set 结构。

```javascript
let set = new Set(["red", "green", "blue"]);
let arr = [...set];
// ['red', 'green', 'blue']
```

扩展运算符和 Set 结构相结合，就可以去除数组的重复成员。

```javascript
let arr = [3, 5, 2, 2, 5, 5];
let unique = [...new Set(arr)];
// [3, 5, 2]
```

而且，数组的`map`和`filter`方法也可以间接用于 Set 了。

```javascript
let set = new Set([1, 2, 3]);
set = new Set([...set].map((x) => x * 2));
// 返回Set结构：{2, 4, 6}

let set = new Set([1, 2, 3, 4, 5]);
set = new Set([...set].filter((x) => x % 2 == 0));
// 返回Set结构：{2, 4}
```

因此使用 Set 可以很容易地实现并集（Union）、交集（Intersect）和差集（Difference）。

```javascript
let a = new Set([1, 2, 3]);
let b = new Set([4, 3, 2]);

// 并集
let union = new Set([...a, ...b]);
// Set {1, 2, 3, 4}

// 交集
let intersect = new Set([...a].filter((x) => b.has(x)));
// set {2, 3}

// （a 相对于 b 的）差集
let difference = new Set([...a].filter((x) => !b.has(x)));
// Set {1}
```

##### [349. 两个数组的交集](https://leetcode-cn.com/problems/intersection-of-two-arrays/)

```js
var intersection = function (nums1, nums2) {
  const set1 = new Set(nums1);
  const set2 = new Set([...nums2].filter((item) => set1.has(item)));
  return [...new Set(set2)];
};
const nums1 = [1, 2, 2, 1];
const nums2 = [2, 2];
intersection(nums1, nums2);
console.log(intersection(nums1, nums2));
```

#### 9、字典

- 与集合类似，字典也是存储唯一值得数据结构，是以键值对(映射关系)的形式来存储
- ES6 中有字典，Map

##### 1、基本用法

ES6 提供了 Map 数据结构。它类似于对象，也是键值对的集合，但是“键”的范围不限于字符串，各种类型的值（包括对象）都可以当作键。也就是说，Object 结构提供了“字符串—值”的对应，Map 结构提供了“值—值”的对应，是一种更完善的 Hash 结构实现。如果你需要“键值对”的数据结构，Map 比 Object 更合适。

```javascript
const m = new Map();
m.set("name", "张三");
m.get("name");
console.log(m.get("name")); // 张三
console.log(m.has("name")); // true
console.log(m.has("age")); // false
console.log(m.delete("name")); // true
console.log(m.has("name")); // false
```

作为构造函数，Map 也可以接受一个数组作为参数。该数组的成员是一个个表示键值对的数组。

```javascript
const map = new Map([
  ["name", "张三"],
  ["title", "Author"],
]);

map.size; // 2
map.has("name"); // true
map.get("name"); // "张三"
map.has("title"); // true
map.get("title"); // "Author"
```

如果读取一个未知的键，则返回`undefined`。

```javascript
new Map().get("asfddfsasadf");
// undefined
```

注意，只有对同一个对象的引用，Map 结构才将其视为同一个键。这一点要非常小心。

```javascript
const map = new Map();

map.set(["a"], 555);
map.get(["a"]); // undefined
```

上面代码的`set`和`get`方法，表面是针对同一个键，但实际上这是两个不同的数组实例，内存地址是不一样的，因此`get`方法无法读取该键，返回`undefined`。

同理，同样的值的两个实例，在 Map 结构中被视为两个键。

```javascript
const map = new Map();

const k1 = ["a"];
const k2 = ["a"];

map.set(k1, 111).set(k2, 222);

map.get(k1); // 111
map.get(k2); // 222
```

##### 2、实例的属性和操作方法

**（1）size 属性**

`size`属性返回 Map 结构的成员总数。

```javascript
const map = new Map();
map.set("foo", true);
map.set("bar", false);

map.size; // 2
```

**（2）Map.prototype.set(key, value)**

`set`方法设置键名`key`对应的键值为`value`，然后返回整个 Map 结构。如果`key`已经有值，则键值会被更新，否则就新生成该键。

```javascript
const m = new Map();

m.set("edition", 6); // 键是字符串
m.set(262, "standard"); // 键是数值
m.set(undefined, "nah"); // 键是 undefined
```

`set`方法返回的是当前的`Map`对象，因此可以采用链式写法。

```javascript
let map = new Map().set(1, "a").set(2, "b").set(3, "c");
```

**（3）Map.prototype.get(key)**

`get`方法读取`key`对应的键值，如果找不到`key`，返回`undefined`。

```javascript
const m = new Map();

const hello = function () {
  console.log("hello");
};
m.set(hello, "Hello ES6!"); // 键是函数

m.get(hello); // Hello ES6!
```

**（4）Map.prototype.has(key)**

`has`方法返回一个布尔值，表示某个键是否在当前 Map 对象之中。

```javascript
const m = new Map();

m.set("edition", 6);
m.set(262, "standard");
m.set(undefined, "nah");

m.has("edition"); // true
m.has("years"); // false
m.has(262); // true
m.has(undefined); // true
```

**（5）Map.prototype.delete(key)**

`delete`方法删除某个键，返回`true`。如果删除失败，返回`false`。

```javascript
const m = new Map();
m.set(undefined, "nah");
m.has(undefined); // true

m.delete(undefined);
m.has(undefined); // false
```

**（6）Map.prototype.clear()**

`clear`方法清除所有成员，没有返回值。

```javascript
let map = new Map();
map.set("foo", true);
map.set("bar", false);

map.size; // 2
map.clear();
map.size; // 0
```

**（1）size 属性**

`size`属性返回 Map 结构的成员总数。

```javascript
const map = new Map();
map.set("foo", true);
map.set("bar", false);

map.size; // 2
```

**（2）Map.prototype.set(key, value)**

`set`方法设置键名`key`对应的键值为`value`，然后返回整个 Map 结构。如果`key`已经有值，则键值会被更新，否则就新生成该键。

```javascript
const m = new Map();

m.set("edition", 6); // 键是字符串
m.set(262, "standard"); // 键是数值
m.set(undefined, "nah"); // 键是 undefined
```

`set`方法返回的是当前的`Map`对象，因此可以采用链式写法。

```javascript
let map = new Map().set(1, "a").set(2, "b").set(3, "c");
```

**（3）Map.prototype.get(key)**

`get`方法读取`key`对应的键值，如果找不到`key`，返回`undefined`。

```javascript
const m = new Map();

const hello = function () {
  console.log("hello");
};
m.set(hello, "Hello ES6!"); // 键是函数

m.get(hello); // Hello ES6!
```

**（4）Map.prototype.has(key)**

`has`方法返回一个布尔值，表示某个键是否在当前 Map 对象之中。

```javascript
const m = new Map();

m.set("edition", 6);
m.set(262, "standard");
m.set(undefined, "nah");

m.has("edition"); // true
m.has("years"); // false
m.has(262); // true
m.has(undefined); // true
```

**（5）Map.prototype.delete(key)**

`delete`方法删除某个键，返回`true`。如果删除失败，返回`false`。

```javascript
const m = new Map();
m.set(undefined, "nah");
m.has(undefined); // true

m.delete(undefined);
m.has(undefined); // false
```

**（6）Map.prototype.clear()**

`clear`方法清除所有成员，没有返回值。

```javascript
let map = new Map();
map.set("foo", true);
map.set("bar", false);

map.size; // 2
map.clear();
map.size; // 0
```

**（1）size 属性**

`size`属性返回 Map 结构的成员总数。

```javascript
const map = new Map();
map.set("foo", true);
map.set("bar", false);

map.size; // 2
```

**（2）Map.prototype.set(key, value)**

`set`方法设置键名`key`对应的键值为`value`，然后返回整个 Map 结构。如果`key`已经有值，则键值会被更新，否则就新生成该键。

```javascript
const m = new Map();

m.set("edition", 6); // 键是字符串
m.set(262, "standard"); // 键是数值
m.set(undefined, "nah"); // 键是 undefined
```

`set`方法返回的是当前的`Map`对象，因此可以采用链式写法。

```javascript
let map = new Map().set(1, "a").set(2, "b").set(3, "c");
```

**（3）Map.prototype.get(key)**

`get`方法读取`key`对应的键值，如果找不到`key`，返回`undefined`。

```javascript
const m = new Map();

const hello = function () {
  console.log("hello");
};
m.set(hello, "Hello ES6!"); // 键是函数

m.get(hello); // Hello ES6!
```

**（4）Map.prototype.has(key)**

`has`方法返回一个布尔值，表示某个键是否在当前 Map 对象之中。

```javascript
const m = new Map();

m.set("edition", 6);
m.set(262, "standard");
m.set(undefined, "nah");

m.has("edition"); // true
m.has("years"); // false
m.has(262); // true
m.has(undefined); // true
```

**（5）Map.prototype.delete(key)**

`delete`方法删除某个键，返回`true`。如果删除失败，返回`false`。

```javascript
const m = new Map();
m.set(undefined, "nah");
m.has(undefined); // true

m.delete(undefined);
m.has(undefined); // false
```

**（6）Map.prototype.clear()**

`clear`方法清除所有成员，没有返回值。

```javascript
let map = new Map();
map.set("foo", true);
map.set("bar", false);

map.size; // 2
map.clear();
map.size; // 0
```

##### 3、遍历方法

Map 结构原生提供三个遍历器生成函数和一个遍历方法。

- `Map.prototype.keys()`：返回键名的遍历器。
- `Map.prototype.values()`：返回键值的遍历器。
- `Map.prototype.entries()`：返回所有成员的遍历器。
- `Map.prototype.forEach()`：遍历 Map 的所有成员。

需要特别注意的是，Map 的遍历顺序就是插入顺序。

```javascript
// 遍历方法
const m2 = new Map().set("a", 1).set("b", 2).set("c", 3);
for (const item of m2.keys()) {
  console.log(item); // a,b,c
}
for (const item of m2.values()) {
  console.log(item); // 1,2,3
}
for (const item of m2.entries()) {
  console.log(item); // ["a", 1]["b", 2] ["c", 3]
}
```

Map 结构转为数组结构，比较快速的方法是使用扩展运算符（`...`）。

```javascript
const map = new Map([
  [1, 'one'],
  [2, 'two'],
  [3, 'three'],
]);

[...map.keys()]
// [1, 2, 3]

[...map.values()]
// ['one', 'two', 'three']

[...map.entries()]
// [[1,'one'], [2, 'two'], [3, 'three']]

[...map]
// [[1,'one'], [2, 'two'], [3, 'three']]
```

##### 4、与其他数据结构的互相转换

**（1）Map 转为数组**

前面已经提过，Map 转为数组最方便的方法，就是使用扩展运算符（`...`）。

```javascript
const myMap = new Map().set(true, 7).set({ foo: 3 }, ["abc"]);
[...myMap];
// [ [ true, 7 ], [ { foo: 3 }, [ 'abc' ] ] ]
```

**（2）数组 转为 Map**

将数组传入 Map 构造函数，就可以转为 Map。

```javascript
new Map([
  [true, 7],
  [{ foo: 3 }, ["abc"]],
]);
// Map {
//   true => 7,
//   Object {foo: 3} => ['abc']
// }
```

**（3）Map 转为对象**

如果所有 Map 的键都是字符串，它可以无损地转为对象。

```javascript
function strMapToObj(strMap) {
  let obj = Object.create(null);
  for (let [k, v] of strMap) {
    obj[k] = v;
  }
  return obj;
}

const myMap = new Map().set("yes", true).set("no", false);
strMapToObj(myMap);
// { yes: true, no: false }
```

如果有非字符串的键名，那么这个键名会被转成字符串，再作为对象的键名。

**（4）对象转为 Map**

对象转为 Map 可以通过`Object.entries()`。

```javascript
let obj = { a: 1, b: 2 };
let map = new Map(Object.entries(obj));
```

##### 5、算法题解析

###### [349. 两个数组的交集](https://leetcode-cn.com/problems/intersection-of-two-arrays/)

![img](https://img-blog.csdnimg.cn/20210614103333685.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1dlYl9TdHJ1Z2dsZQ==,size_16,color_FFFFFF,t_70)

```js
//  Map解题
var intersection = function (nums1, nums2) {
  const map = new Map();
  nums1.forEach(item => {
    map.set(item, true)
  })
  const res = [];
  nums2.forEach(item => {
    if (map.get(item)) {
      res.push(item)
      map.delete(item)
    }
  })
  return res;
};
```

###### [20. 有效的括号](https://leetcode-cn.com/problems/valid-parentheses/)

```js
/**
 * @param {string} s
 * @return {boolean}
 */
var isValid = function(s) {
    if(s.length % 2 == 1) {return false}
    const stack = [];
    const map = new Map();
    map.set('(',')')
    map.set('[',']')
    map.set('{','}')
    for(let i = 0; i < s.length; i++) {
        const t = s[i];
        if(map.get(t)) {
            stack.push(t) // 入栈
        }else {
            const top = stack[stack.length - 1] // 获取栈顶元素
            if(t === map.get(top)) {
                stack.pop();
            }else {
                return false
            }
        }
    }
    return stack.length === 0;
};
```

###### [1. 两数之和](https://leetcode-cn.com/problems/two-sum/)

```js
/**
 * @param {number[]} nums
 * @param {number} target
 * @return {number[]}
 */
var twoSum = function(nums, target) {
    const map = new Map();
    if(nums.length) {
        for(let i = 0;i < nums.length; i++) {
            const n1 = nums[i]
            const n2 = target - n1 // target = 两个整数之和
            if(map.has(n2)) {
                return [map.get(n2),i]
            }else {
                map.set(n1,i)
            }
        }
    }
};
```

###### [3. 无重复字符的最长子串](https://leetcode-cn.com/problems/longest-substring-without-repeating-characters/)

```js
/**
 * @param {string} s
 * @return {number}
 */
var lengthOfLongestSubstring = function(s) {
    let l = 0; // 左指针的初始位置
    let res = 0; // 长度初始值为0
    const map = new Map();
    for(let r = 0; r < s.length; r++) {
        if(map.has(s[r]) && map.get(s[r]) >= l ) {
            l = map.get(s[r]) + 1;
        }
        res = Math.max(res, r - l + 1);
        map.set(s[r], r);
    }
    return res;
};
```

#### 10、树

- 一种分层数据的抽象模型
- 前端工作常见的树：`DOM`树，级联选择器，树形控件等。
- `JS`没有树，可以用`Object`和`Array`构建树。

```js
// 树的模型
{
    value:'gd',
    id:19,
    children:[
        {
            value:'gz',
    		id:2344,
            children:[
                {
                    value:'ht',
                    id:36888,
                }
            ]
        }
    ]
}
```

- 树的常用操作：深度、广度优先遍历，先中后序遍历

##### 10-1深度、广度优先遍历

![img](https://img-blog.csdnimg.cn/20210614165532518.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1dlYl9TdHJ1Z2dsZQ==,size_16,color_FFFFFF,t_70)

**可以这么理解：深度优先遍历表示从头一页一页的看一本书，而广度优先遍历表示：先看书的目录。再深入了解书的章节**

##### 10-2深度优先遍历的算法口诀

1. 访问根节点
2. 对根节点的`children`挨个进行深度优先遍历(即递归)

**代码实现**

```js
const tree = {
  val: 'a',
  children: [{
    val: 'b',
    children: [{
      val: 'd',
      children: [],
    }, {
      val: 'e',
      children: [],
    }],
  }, {
    val: 'c',
    children: [{
      val: 'f',
      children: [],
    }, {
      val: 'g',
      children: [],
    }],
  }],
}
const dfs = (root) => {
  console.log(root.val);
  root.children.forEach(dfs) // 采用递归调用
}
dfs(tree); // a,b,d,e,c,f,g
```

##### 10-3广度优先遍历的算法口诀

![img](https://img-blog.csdnimg.cn/20210614172458836.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1dlYl9TdHJ1Z2dsZQ==,size_16,color_FFFFFF,t_70)

1. 新建一个队列，把根节点挨个入队
2. 把对头出队，进行访问
3. 把对头的`children`挨个入队
4. 重复2,3的步骤，直到队列为空

```js
const tree = {
  val: 'a',
  children: [{
    val: 'b',
    children: [{
      val: 'd',
      children: [],
    }, {
      val: 'e',
      children: [],
    }],
  }, {
    val: 'c',
    children: [{
      val: 'g',
      children: [],
    }, {
      val: 'f',
      children: [],
    }],
  }],
}
const bfs = (root) => {
  const q = [root]
  while (q.length > 0) {
    const n = q.shift(); // 对头出队
    console.log(n.val)
    n.children.forEach(item => { // 把对头的`children`挨个入队
      q.push(item)
    })
  }
}
bfs(tree) // a,b,c,d,e,f,g
```

##### 10-4二叉树

1. 树中的节点最多只能有两个字节点
2. 在`JS`中通常用`Object`来模拟二叉树

**二叉树模型**

```js
{
    val:'1',
    left:{
        val:'2',
        left:null,
        right:null
    },
    right:{
       val:'3',
       left:null,
       right:null
    }
}
```

###### 10-4-1二叉树，先序遍历算法口诀

![img](https://img-blog.csdnimg.cn/20210614174924117.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1dlYl9TdHJ1Z2dsZQ==,size_16,color_FFFFFF,t_70)

**代码实现**

```js
const bt = {
  val: '1',
  left: {
    val: '2',
    left: {
      val: '4',
      left: null,
      right: null
    },
    right: {
      val: '5',
      left: null,
      right: null
    }
  },
  right: {
    val: '3',
    left: {
      val: '6',
      left: null,
      right: null
    },
    right: {
      val: '7',
      left: null,
      right: null
    }
  }
}
// (递归版)
const preorder = (root) => {
  if (!root) {
    return false
  }
  console.log(root.val) // 1,2,4,5,3,6,7
  preorder(root.left) // 对根节点的左子树进行先序遍历。
  preorder(root.right) // 对根节点的右子树进行先序遍历。
}
preorder(bt)
/**
 * 非递归
 * 由于先访问根节点，可以看做栈来操作
 */
const preorder = (root) => {
  if (!root) {
    return false
  }
  const stack = [root];
  while (stack.length) {
    const n = stack.pop(); // 先访问栈顶元素，即根节点
    console.log(n.val); // 1,2,4,5,3,6,7
    // 根据后进先出，先操作右子树进行先序遍历
    if (n.right) stack.push(n.right)
    if (n.left) stack.push(n.left)
  }
}
preorder(bt)

```

###### 10-4-2二叉树，中序遍历算法口诀

![img](https://img-blog.csdnimg.cn/20210614201747160.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1dlYl9TdHJ1Z2dsZQ==,size_16,color_FFFFFF,t_70)

**代码实现**

```js
const bt = require('./bt.js')
// 递归
const inorder = (root) => {
  if (!root) {
    return false
  }
  inorder(root.left) // 对根节点的左子树进行中序遍历。
  console.log(root.val) // 4,2,5,1,6,3,7
  inorder(root.right) // 对根节点的右子树进行中序遍历。
}
inorder(bt)
/**
 * 非递归
 */
const inorder = (root) => {
  if (!root) {
    return false
  }
  const stack = [];
  let p = root;
  while (stack.length || p) {
    while (p) {
      stack.push(p);
      p = p.left
    }
    const n = stack.pop();
    console.log(n.val); // 4,2,5,1,6,3,7
    p = n.right
  }
}
inorder(bt)
```

###### 10-4-2二叉树，后序遍历算法口诀

![img](https://img-blog.csdnimg.cn/20210614202413317.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1dlYl9TdHJ1Z2dsZQ==,size_16,color_FFFFFF,t_70)

**代码实现**

```js
const bt = require('./bt.js')
// 递归版
const mdorder = (root) => {
  if (!root) {
    return false
  }
  mdorder(root.left) // 对根节点的左子树进行中序遍历。
  mdorder(root.right) // 对根节点的右子树进行中序遍历。
  console.log(root.val) // 4,5,2,6,7,3,1
}
mdorder(bt)
// 非递归
const mdorder = (root) => {
  if (!root) {
    return false
  }
  const stack = [root];
  const outPutStack = [];
  while (stack.length) {
    const n = stack.pop(); // 先访问栈顶元素，即根节点
    outPutStack.push(n) // 存入到逆向输出的数组里
    if (n.left) stack.push(n.left)
    if (n.right) stack.push(n.right)
  }
  while (outPutStack.length) {
    const n = outPutStack.pop();
    console.log(n.val); // 4,5,2,6,7,3,1
  }
}
mdorder(bt)
```

##### 10-5算法题解析

###### [104. 二叉树的最大深度](https://leetcode-cn.com/problems/maximum-depth-of-binary-tree/)

![img](https://img-blog.csdnimg.cn/20210614233201431.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1dlYl9TdHJ1Z2dsZQ==,size_16,color_FFFFFF,t_70)

```js
var maxDepth = function(root) {
    let res = 0 ;
    const dfs = (item,l) => {
        if(!item) {return false;}
        if(!item.left && !item.right) {
            res = Math.max(res, l)
        }
        dfs(item.left,l+1)
        dfs(item.right,l+1)
    }
    dfs(root,1)
    return res
};
```



###### [111. 二叉树的最小深度](https://leetcode-cn.com/problems/minimum-depth-of-binary-tree/)

![img](https://img-blog.csdnimg.cn/20210615165112814.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1dlYl9TdHJ1Z2dsZQ==,size_16,color_FFFFFF,t_70)

```js
/**
 * @param {TreeNode} root
 * @return {number}
 */
var minDepth = function(root) {
    if (!root) {
            return 0;
        }
        const q = [[root,1]]
        while(q.length) {
             const [n,l] = q.shift();
             if(!n.left && !n.right) {
                 return l;
             }
             if(n.left) q.push([n.left, l+ 1])
             if(n.right) q.push([n.right, l+ 1])
        } 
};
```

###### [102. 二叉树的层序遍历](https://leetcode-cn.com/problems/binary-tree-level-order-traversal/)

```js
/**
 * @param {TreeNode} root
 * @return {number[][]}
 */
var levelOrder = function(root) {
    if(!root) {return [];}
    const q = [[root,0]];
    let res = [];
    while(q.length) {
        const [n,leave] = q.shift();
        if(!res[leave]) { // 层级为0 的时候，根节点入队
            res.push([n.val])
        }else {
            res[leave].push(n.val) // 根据层级添加对应的val值
        }
        console.log(n.val,leave)
        if(n.left) q.push([n.left,leave+1]);
        if(n.right) q.push([n.right,leave+1]);
    }
    return res;
};
```

###### [94. 二叉树的中序遍历](https://leetcode-cn.com/problems/binary-tree-inorder-traversal/)

```js
/**
 * @param {TreeNode} root
 * @return {number[]}
 * 二叉树中序遍历
 */
var inorderTraversal = function(root) {
    if(!root) {return [];}
        const stack = [];
        const res =[];
        let p = root;
        while(stack.length || p) {
            while(p) {
            stack.push(p);
            p = p.left;
        }
            const n = stack.pop();
            res.push(n.val)
            p = n.right;
        }
        return res;
};
```

###### [112. 路径总和](https://leetcode-cn.com/problems/path-sum/)

![img](https://img-blog.csdnimg.cn/20210615165143405.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1dlYl9TdHJ1Z2dsZQ==,size_16,color_FFFFFF,t_70)

```js
/**
 * @param {TreeNode} root
 * @param {number} targetSum
 * @return {boolean}
 */
var hasPathSum = function(root, targetSum) {
    if(!root) {return false;}
    let res = false;
    const dfs = (n,sum) => {
        // 深度优先遍历
        console.log(n.val,sum);
        if(!n.left && !n.right && sum == targetSum) {
            res = true;
        }
        if(n.left) dfs(n.left,sum + n.left.val);
        if(n.right) dfs(n.right,sum + n.right.val);
    }
    dfs(root,root.val)
    return res;
};
```



#### 11、图

##### 11-1图是什么？

- 图是网络结构的抽象模型，是一-组由边连接的节点。

- 图可以表示任何二元关系，比如道路、航班。
- JS中没有图,但是可以用`Object`和`Array`构建图。
- 图的表示法:邻接矩阵、邻接表、关联矩....

![img](https://img-blog.csdnimg.cn/20210616170859945.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1dlYl9TdHJ1Z2dsZQ==,size_16,color_FFFFFF,t_70)

**如果节点A能连接到节点B，那么矩阵B对应的行或者列表示为1，否则为0**

![img](https://img-blog.csdnimg.cn/20210616171155367.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1dlYl9TdHJ1Z2dsZQ==,size_16,color_FFFFFF,t_70)

**节点A能连接到节点B，那么A：["B"]，这个比较好理解的。**

图的常用操作

- 深度优先遍历
- 广度优先遍历

##### 11-2图的深度优先遍历算法口诀

1. 访问根节点。
2. 对根节点的**没访问过的相邻节点**挨个进行深度优先遍历。

![img](https://img-blog.csdnimg.cn/20210616173150909.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1dlYl9TdHJ1Z2dsZQ==,size_16,color_FFFFFF,t_70)

**没访问过的相邻节点**：如上图所示，如果从节点2开始遍历，优先遍历节点0,节点0在返回到节点2就会造成死循环，如果加个没访问过的相邻节点判断，就会寻找下个非访问过的节点了。

**代码实现**

```js
// graph.js
const graph = {
  0:[1,2],
  1:[2],
  2:[0,3],
  3:[3]
}
module.exports = graph;
// dfs.js
const graph = require('./graph');
// 声明一个集合，记录已遍历过的节点
const isVistive = new Set();
const dfs =(n) => {
  console.log(n); // 2,0,1,3
  isVistive.add(n); // 记录已遍历过的节点
  graph[n].forEach(item => {
    if(!isVistive.has(item)) {
      dfs(item)
    }
  })
}
dfs(2);
```



##### 11-3图的广度优先遍历算法口诀

1. 新建一个队列，把根节点入队。
2. 把队头出队并访问。
3. 把队头的没访问过的相邻节点入队。
4. 重复第二、三步，直到队列为空。

**代码实现**

```js
const graph = require('./graph');
// 声明一个集合，记录已遍历过的节点
const isVistive = new Set();
isVistive.add(2) // 先把初始节点添加到集合
const bfs = () => {
  const q = [2];
  while (q.length) {
    const n = q.shift();
    console.log(n);// 2,0,3,1
    graph[n].forEach(item => {
      if (!isVistive.has(item)) {
        q.push(item)
        isVistive.add(item);
      }
    })
  }
}
bfs();
```

##### 11-4 算法题

###### [65. 有效数字](https://leetcode-cn.com/problems/valid-number/)

![img](https://img-blog.csdnimg.cn/20210616224907300.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1dlYl9TdHJ1Z2dsZQ==,size_16,color_FFFFFF,t_70)

**图片描述**：  编号1，开始走节点6的位置，最终停留在节点6，所以0是有效数字。编号3，a开头无路可走，所以编号3是无效数字。只有遍历到节点3、5、6的时候，数字才是有效数字。

**解题步骤**

1. 构建一个表示状态的图。
2. 遍历字符串，并沿着图走，如果到了某个节点无路可走就返false
3. 遍历结束，如走到3/5/6，就返回true，否则返回false。

```js
/**
 * @param {string} s
 * @return {boolean}
 */
var isNumber = function(s) {
    const graph = {
        0:{'blank':0,'digit':6,'sign':1,'.':2},
        1:{'digit':6, '.':2},
        2:{'digit':3},
        3:{'digit':3, 'e':4},
        4:{'digit':5,'sign':7},
        5:{'digit':5},
        6:{'digit':6, '.':3, 'e':4},
        7:{'digit':5}
    }
    let state = 0; // 初始状态值为0；
    for(item of s.trim()) {
        if(item >= '0' && item <= '9') {
            item = 'digit'
        }else if(item === '') {
            item = 'blank'
        }else if(item === '+' || item === '-') {
            item = 'sign'
        }else if(item === 'e' || item === 'E') {
            item = 'e'
        }
        state = graph[state][item]
        if(state == undefined) {
            return false;
        }
    }
    if(state == 3 || state == 6 || state == 5) {
        return true;
    }
    return false;
};
```



###### [417. 太平洋大西洋水流问题](https://leetcode-cn.com/problems/pacific-atlantic-water-flow/)

```shell
给定下面的 5x5 矩阵:
  太平洋 ~   ~   ~   ~   ~ 
       ~  1   2   2   3  (5) *
       ~  3   2   3  (4) (4) *
       ~  2   4  (5)  3   1  *
       ~ (6) (7)  1   4   5  *
       ~ (5)  1   1   2   4  *
          *   *   *   *   * 大西洋
```

**解题步骤**

1. 新建两个矩阵,分别记录能流到两个大洋的坐标。
2. 从海岸线,多管齐下，同时深度优先遍历图,过程中填充上述矩阵。
3. 遍历两个矩阵，找出能流到两个大洋的坐标。

```js
/**
 * @param {number[][]} heights
 * @return {number[][]}
 */
var pacificAtlantic = function (heights) {
    if (!heights || !heights[0] || !heights[0].length) return []
    const m = heights.length
    const n = heights[0].length
    // 逆流而上，走出一条通道
    // 存放太平洋->大西洋的路径
    const flow1 = Array.from({ length: m }, () => {
        return Array.from({ length: n }, () => false)
    })
    // 存放大西洋->太平洋的路径
    const flow2 = Array.from({ length: m }, () => {
        return Array.from({ length: n }, () => false)
    })
    const dfs = (r, c, flow) => {
        flow[r][c] = true;
        [[r - 1, c], [r, c + 1], [r + 1, c], [r, c - 1]].forEach(([nr, nc]) => {
            if (nr >= 0 && nr < m &&
                nc >= 0 && nc < n &&
                !flow[nr][nc] &&
                heights[nr][nc] >= heights[r][c]
            ) {
                dfs(nr, nc, flow)
            }
        })
    }
    //多管齐下, 第一行遍历到最后行，第一列遍历到最后列
    for (let i = 0; i < m; i++) {
        dfs(i, 0, flow1)
        dfs(i, n - 1, flow2)
    }
    for (let i = 0; i < n; i++) {
        dfs(0, i, flow1)
        dfs(m - 1, i, flow2)
    }
    // 找出两条路都能走通的节点
    const res = []
    for (let i = 0; i < m; i++) {
        for (let j = 0; j < n; j++) {
            if (flow1[i][j] && flow2[i][j]) {
                res.push([i, j])
            }
        }
    }
    return res
};
```

###### [133. 克隆图](https://leetcode-cn.com/problems/clone-graph/)

#### 12、堆

##### 12-1堆是什么？

![img](https://img-blog.csdnimg.cn/20210618180204299.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1dlYl9TdHJ1Z2dsZQ==,size_16,color_FFFFFF,t_70)



![img](https://img-blog.csdnimg.cn/20210618180240393.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1dlYl9TdHJ1Z2dsZQ==,size_16,color_FFFFFF,t_70)

**上图解释**：index指的是数组的下标索引。

##### 12-2堆的应用

- 堆能高效、快速地找出最大值和最小值，时间复杂度: 0(1)。
- 找出第K个最大(小)元素。

**找出第K个最大元素**

![img](https://img-blog.csdnimg.cn/20210618180330980.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1dlYl9TdHJ1Z2dsZQ==,size_16,color_FFFFFF,t_70)

1. 构建一个最小堆，并将元素依次插入堆中。
2. 当堆的容量超过K,就删除堆顶。
3. 插入结束后，堆顶就是第K个最大元素。

**实现最小堆类**

实现步骤：

1. 在类里，声明-一个数组，用来装元素。
2. 主要方法:插入、删除堆顶、获取堆顶、获取堆大小。

##### **插入方法**

1. 将值插入堆的底部，即数组的尾部。
2. 然后上移:将这个值和它的父节点进行交换，直到父节点小于等于这个插入的值。
3. 大小为k的堆中插入元素的时间复杂度为O(logk)。

**代码实现**

```js
// 插入方法，获取第K个最小元素
class MinHeap {
  constructor() {
    this.heap = [];
  }
  // 交换函数
  swap(i1,i2){
    let temp = this.heap[i1]
    this.heap[i1] = this.heap[i2]
    this.heap[i2] = temp;
  }
  // 获取父节点的位置  (index -1 ) / 2 的余数
  getParentIndex(i) {
    return (i - 1) >> 1
  }
  // 上移操作:将这个值和它的父节点进行交换，直到父节点小于等于这个插入的值。
  shiftUp(index){
    // index == 0 到栈顶了， 就返回
    if(index == 0) {return;}
    const parentIndex = this.getParentIndex(index);
    // 和父节点交换
    if(this.heap[parentIndex] > this.heap[index]) {
      this.swap(parentIndex,index)
      this.shiftUp(parentIndex)
    }
  }
  // 将值插入堆的底部
  insert(value) {
    this.heap.push(value)
    this.shiftUp(this.heap.length - 1)
  }
}
const h = new MinHeap();

h.insert(3)
h.insert(2)
h.insert(1)
```

##### **删除堆顶**

1. 用数组尾部元素替换堆顶(直接删除堆顶会破坏堆结构)。
2. 然后下移:将新堆顶和它的子节点进行交换，直到子节点大于等于这个新堆顶。
3. 大小为k的堆中删除堆顶的时间复杂度为O(logk)。

**代码实现**

```js
// 插入方法，获取第K个最小元素
class MinHeap {
  constructor() {
    this.heap = [];
  }
  // 交换函数
  swap(i1,i2){
    let temp = this.heap[i1]
    this.heap[i1] = this.heap[i2]
    this.heap[i2] = temp;
  }
  // 获取父节点的位置  (index -1 ) / 2 的余数
  getParentIndex(i) {
    return (i - 1) >> 1
  }
  // 获取左节点的位置 index * 2 + 1
  getLeftIndex(i) {
    return i * 2 + 1;
  }
  // 获取右节点的位置 index * 2 + 2
  getRightIndex(i) {
    return i * 2 + 2;
  }
  // 上移操作:将这个值和它的父节点进行交换，直到父节点小于等于这个插入的值。
  shiftUp(index){
    // index == 0 到栈顶了， 就返回
    if(index == 0) {return;}
    const parentIndex = this.getParentIndex(index);
    // 和父节点交换
    if(this.heap[parentIndex] > this.heap[index]) {
      this.swap(parentIndex,index)
      this.shiftUp(parentIndex)
    }
  }
  // 下移，将新堆顶和它的子节点进行交换，直到子节点大于等于这个新堆顶。
  shiftDown(index) {
    const leftIndex = this.getLeftIndex(index);
    const rightIndex = this.getRightIndex(index);
    if(this.heap[leftIndex] < this.heap[index]) {
      this.swap(leftIndex,index)
      this.shiftDown(leftIndex);
    }
    if(this.heap[rightIndex] < this.heap[index]) {
      this.swap(rightIndex,index)
      this.shiftDown(rightIndex);
    }
  }
  // 将值插入堆的底部
  insert(value) {
    this.heap.push(value)
    this.shiftUp(this.heap.length - 1)
  }
  pop() {
    this.heap[0] = this.heap.pop(); // 用数组尾部元素替换堆顶
    this.shiftDown(0)
  }
}
const h = new MinHeap();

h.insert(3)
h.insert(2)
h.insert(1)
h.pop();
```

##### **获取堆顶和堆的大小**

1. 获取堆顶，返回数组的头部
2. 获取堆得大小：返回数组的长度

```js
// 获取堆顶，返回数组的头部
  peek() {
    return this.heap[0]
  }
  // 获取堆得大小：返回数组的长度
  size() {
    return this.heap.length
  }
```

![img](https://img-blog.csdnimg.cn/20210620170048746.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1dlYl9TdHJ1Z2dsZQ==,size_16,color_FFFFFF,t_70)

##### 12-3算法题解

###### [215. 数组中的第K个最大元素](https://leetcode-cn.com/problems/kth-largest-element-in-an-array/)

**解题思路**

1. 构建一个最小堆，一次把元素插入堆中
2. 如果堆得大小超过 k ，就删除堆顶
3. 元素插入结束后，返回堆顶，即最大的第k个元素

```js
/**
 * @param {number[]} nums
 * @param {number} k
 * @return {number}
 */
// 获取最小堆类，前面已经写过了，直接拿来用即可
var findKthLargest = function(nums, k) {
    const h = new MinHeap();
    nums.forEach(item => {
        h.insert(item);
        if(h.size() > k) {
            h.pop();
        }
    })
    return h.peek();
};
```

###### [347. 前 K 个高频元素](https://leetcode-cn.com/problems/top-k-frequent-elements/)

```js
// 插入方法，获取第K个最小元素
class MinHeap {
  constructor() {
    this.heap = [];
  }
  // 交换函数
  swap(i1, i2) {
    let temp = this.heap[i1]
    this.heap[i1] = this.heap[i2]
    this.heap[i2] = temp;
  }
  // 获取父节点的位置  (index -1 ) / 2 的余数
  getParentIndex(i) {
    return (i - 1) >> 1
  }
  // 获取左节点的位置 index * 2 + 1
  getLeftIndex(i) {
    return i * 2 + 1;
  }
  // 获取右节点的位置 index * 2 + 2
  getRightIndex(i) {
    return i * 2 + 2;
  }
  // 上移操作:将这个值和它的父节点进行交换，直到父节点小于等于这个插入的值。
  shiftUp(index) {
    // index == 0 到栈顶了， 就返回
    if (index == 0) {
      return;
    }
    const parentIndex = this.getParentIndex(index);
    // 和父节点交换
    if (this.heap[parentIndex]&&this.heap[parentIndex].value > this.heap[index].value) {
      this.swap(parentIndex, index)
      this.shiftUp(parentIndex)
    }
  }
  // 下移，将新堆顶和它的子节点进行交换，直到子节点大于等于这个新堆顶。
  shiftDown(index) {
    const leftIndex = this.getLeftIndex(index);
    const rightIndex = this.getRightIndex(index);
    if (this.heap[leftIndex]&&this.heap[leftIndex].value < this.heap[index].value) {
      this.swap(leftIndex, index)
      this.shiftDown(leftIndex);
    }
    if (this.heap[rightIndex]&&this.heap[rightIndex].value < this.heap[index].value) {
      this.swap(rightIndex, index)
      this.shiftDown(rightIndex);
    }
  }
  // 将值插入堆的底部
  insert(value) {
    this.heap.push(value)
    this.shiftUp(this.heap.length - 1)
  }
  pop() {
    this.heap[0] = this.heap.pop(); // 用数组尾部元素替换堆顶
    this.shiftDown(0)
  }
  // 获取堆顶，返回数组的头部
  peek() {
    return this.heap[0]
  }
  // 获取堆得大小：返回数组的长度
  size() {
    return this.heap.length
  }
}
/**
 * @param {number[]} nums
 * @param {number} k
 * @return {number[]}
 */
var topKFrequent = function(nums, k) {
    const map = new Map();
    nums.forEach(n => {
        map.set(n, map.has(n) ? map.get(n) + 1: 1)
    })
    const h = new MinHeap();
    map.forEach((value,key) => {
        h.insert({value, key})
        if(h.size() > k) {
            h.pop();
        }
    })
    return h.heap.map( n => n.key)
};
```

#### 13、进阶算法-搜索排序

**`JS`中的排序:数组的`sort`方法。**

**`JS`中的搜索:数组的`indexOf`方法。**

- ###### 十大经典算法排序总结对比

![img](https://upload-images.jianshu.io/upload_images/1867034-1d3e43cdb301fc9b.png?imageMogr2/auto-orient/strip%7CimageView2/2)

##### 名词解释：

**n**: 数据规模
**k**:“桶”的个数
**In-place**: 占用常数内存，不占用额外内存
**Out-place**: 占用额外内存
**稳定性**：排序后2个相等键值的顺序和排序之前它们的顺序相同

##### 13-1 排序算法常见类型

1. 冒泡排序
2. 选择排序
3. 插入排序
4. 归并排序
5. 快速排序 等等

##### 13-2搜索算法常见类型

1. 顺序搜索
2. 二分搜索

##### 13-3冒泡排序

冒泡排序的思路

[算法动画网址](https://visualgo.net/zh)

1. 比较所有相邻元素，如果第一个比第二个大，则交换它们。
2. 一轮下来，可以保证最后一个数是最大的。
3. 执行n-1轮，就可以完成排序。

- 冒泡排序动图演示

![img](https://upload-images.jianshu.io/upload_images/1867034-e19840224b331fae.gif?imageMogr2/auto-orient/strip)

**代码实现**

```js
Array.prototype.bubbleSort = function () {
  for (let i = 0; i < this.length - 1; i++) {
    for (let j = 0; j < this.length - 1 - i; j++) {
      if (this[j] > this[j + 1]) {
        const temp = this[j]
        this[j] = this[j + 1];
        this[j + 1] = temp;
      }
    }
  }
}
const arr = [5, 4, 3, 2, 1]
arr.bubbleSort();
```

##### 13-4选择排序

选择排序思路

1. 找到数组中的最小值，选中它并将其放置在第一位。
2. 接着找到第二小的值，选中它并将其放置在第二位。
3. 以此类推，执行n- 1轮。

选择排序须知：

在时间复杂度上表现最稳定的排序算法之一，因为无论什么数据进去都是O(n²)的时间复杂度。。。所以用到它的时候，数据规模越小越好。唯一的好处可能就是不占用额外的内存空间了吧。

选择排序动图演示：

![img](https://upload-images.jianshu.io/upload_images/1867034-c6cc220cfb2b9ac8.gif?imageMogr2/auto-orient/strip)

**代码实现**

```js
Array.prototype.selectionSort = function () {
  for (let i = 0; i < this.length - 1; i++) {
    let indexMin = i;
    for (let j = i; j < this.length; j++) {
      if (this[j] < this[indexMin]) {
        indexMin = j;
      }
    }
    if (indexMin !== i) { // 当前索引的值不需要和自己比
      const temp = this[i];
      this[i] = this[indexMin]
      this[indexMin] = temp;
    }
  }
}
const arr = [5, 4, 3, 2, 1]
arr.selectionSort();
```

##### 13-5插入排序

插入排序思路

1. 从第二个数开始往前比。
2. 比它大就往后排。
3. 以此类推进行到最后一个数。

插入排序动图演示：

![img](https://upload-images.jianshu.io/upload_images/1867034-d1537e355abdd298.gif?imageMogr2/auto-orient/strip)

**代码实现**

```js
Array.prototype.insertionSort = function () {
  for (let i = 1; i < this.length; i++) {
    const temp = this[i];
    let j = i;
    while (j > 0) {
      if (this[j - i] > temp) {
        this[j] = this[j - i];
      } else {
        break;
      }
      j--;
    }
    this[j] = temp;
  }
}
const arr = [5, 4, 3, 2, 1]
arr.insertionSort();
```

##### 13-6归并排序

1. 分:把数组劈成两半，再递归地对子数组进行，“分”操作，直到分成一个个单独的数。
2. 合:把两个数合并为有序数组，再对有序数组进行合并，直到全部子数组合并为一个完整数组。

**合并两个有序数组**

1. 新建一个空数组res，用于存放最终排序后的数组。
2. 比较两个有序数组的头部，较小者出队并推入res中。
3. 如果两个数组还有值，就重复第二步。

归并排序动画：

![img](https://upload-images.jianshu.io/upload_images/1867034-18c70f637b5c01c2.gif?imageMogr2/auto-orient/strip)

**代码实现**

```js
Array.prototype.mergeSort = function () {
  // 把数组劈成两半，再递归地对子数组进行分，直到把数组分成一个个元素
  const rec = (arr) => {
    if (arr.length == 1) {
      return arr;
    }
    const mid = Math.floor(arr.length / 2);
    let left = arr.slice(0, mid)
    let right = arr.slice(mid, arr.length)
    const orderLeft = rec(left) // 有序左数组
    const orderRight = rec(right) // 有序右数组
    const res = []; // 新建一个空数组res，用于存放最终排序后的数组。
    while (orderLeft.length || orderRight.length) {
      if (orderLeft.length && orderRight.length) {
        // 比较两个有序数组的头部，较小者出队并推入res中。
        res.push(orderLeft[0] < orderRight[0] ? orderLeft.shift() : orderRight.shift())
      } else if (orderLeft.length) { // 如果两个数组还有值，就重复第二步。
        res.push(orderLeft.shift())
      } else if (orderRight.length) { // 如果两个数组还有值，就重复第二步。
        res.push(orderRight.shift())
      }
    }
    return res;
  }
  // 挂到原始数组里去
  const res = rec(this)
  res.forEach((n, i) => {
    this[i] = n;
  })
}
const arr = [5, 4, 3, 2, 1]
arr.mergeSort();
```

##### 13-7快速排序

**快速排序思路**

1. 分区:从数组中任意选择一个“基准”，所有比基准小的元素放在基准前面，比基准大的元素放在基准的后面。
2. 递归:递归地对基准前后的子数组进行分区。

快速排序动画：

![img](https://upload-images.jianshu.io/upload_images/1867034-cd65e35d7dce5045.gif?imageMogr2/auto-orient/strip)

**代码实现**

```js
Array.prototype.quickSort = function () {
  const rec = (arr) => {
    if (arr.length === 1) {
      return arr;
    }
    const left = []; // 存放基准前面的元素
    const right = []; // 存放基准前面的元素
    const base = arr[0]; // 基准，这里选择第一个元素
    for (let i = 1; i < arr.length; i++) {
      if (arr[i] < base) {
        left.push(arr[i])
      } else {
        right.push(arr[i])
      }
    }
    return [...rec(left), base, ...rec(right)]
  }
  // 挂到原始数组里去
  const res = rec(this)
  res.forEach((n, i) => {
    this[i] = n;
  })
}
const arr = [2, 4, 5, 3, 1]
arr.quickSort();
```

##### 13-8顺序搜索

顺序搜索思路

1. 遍历数组
2. 找到跟目标值相等的元素，就返回它的下标。
3. 遍历结束后，如果没有搜索到目标值，就返回-1

**代码实现**

```js
Array.prototype.sequenceSeach = function (target) {
  for (let i = 0; i < this.length; i++) {
    if (this[i] == target) {
      return i
    }
  }
  return -1;
}
const res = [1, 2, 3, 4, 5].sequenceSeach(3)
```

##### 13-9二分搜索

二分搜索思路

1. 从数组的中间元素开始，如果中间元素正好是目标值，则搜索结束。
2. 如果目标值大于或者小于中间元素，则在大于或小于中间元素的那一半数组中搜索。

**代码实现**

```js
Array.prototype.binarySearch = function (target) {
  let low = 0; // 最小索引
  let heigh = this.length - 1; // 最大索引
  while (low <= heigh) {
    const mid = Math.floor((low + heigh) / 2) // 获取中间元素下标
    const ele = this[mid] // 获取中间元素的值
    if (ele < target) {
      low = mid + 1;
    } else if (ele > target) {
      heigh = mid - 1
    } else {
      return mid; // 如果中间元素正好是目标值，则搜索结束。
    }
  }
  return -1;
}
const res = [1, 2, 3, 4, 5].binarySearch(4)
```

##### 13-10算法题

###### [21. 合并两个有序链表](https://leetcode-cn.com/problems/merge-two-sorted-lists/)

解题步骤

1. 新建一个新链表，作为返回结果。
2. 用指针遍历两个有序链表，并比较两个链表的当前节点较小者先接入新链表，并将指针后移一步。
3. 链表遍历结束，返回新链表。

```js
/**
 * Definition for singly-linked list.
 * function ListNode(val, next) {
 *     this.val = (val===undefined ? 0 : val)
 *     this.next = (next===undefined ? null : next)
 * }
 */
/**
 * @param {ListNode} l1
 * @param {ListNode} l2
 * @return {ListNode}
 */
var mergeTwoLists = function(l1, l2) {
    const res = new ListNode(0);
    let p = res;
    let p1 = l1;
    let p2 = l2;
    while(p1 && p2) {
        if(p1.val < p2.val) {
            p.next = p1;
            p1 = p1.next;
        }else {
            p.next = p2;
            p2 = p2.next;
        }
        p = p.next;
    }
    if(p1) {
        p.next = p1;
    }
    if(p2) {
        p.next = p2;
    }
    return res.next;
};
```

###### [374. 猜数字大小](https://leetcode-cn.com/problems/guess-number-higher-or-lower/)

解题步骤

二分搜索思路

1. 从数组的中间元素开始，如果中间元素正好是目标值，则搜索结束。
2. 如果目标值大于或者小于中间元素，则在大于或小于中间元素的那一半数组中搜索。

```js
/** 
 * Forward declaration of guess API.
 * @param {number} num   your guess
 * @return 	            -1 if num is lower than the guess number
 *			             1 if num is higher than the guess number
 *                       otherwise return 0
 * var guess = function(num) {}
 */

/**
 * @param {number} n
 * @return {number}
 */
var guessNumber = function(n) {
    let low = 1;
    let heigh = n;
    while(low <= heigh) {
        // 获取中间元素的值
        const mid = Math.floor((low + heigh) / 2);
        const res = guess(mid) // 来获取猜测结果，也就是中间元素
        if(res === 0) {
            return mid
        }else if(res === 1) {
            low = mid + 1;
        }else {
            heigh = mid - 1;
        }
    }
};
```



#### 14、 算法思想之“分而治之”

##### 14-1分而治之是什么?

1. 分而治之是算法设计中的一-种方法。
2. 它将一个问题分成多个和原问题相似的小问题，递归解决小问题，再将结果合并以解决原来的问题。

###### 14-1-1分而治之场景-归并排序

1. 分：讲数组从中间一分为二
2. 解：递归地对两个子数组进行归并排序。（直到把数组分成长度为1的子数组）
3. 合：合并有序数组

###### 14-1-2分而治之场景-快速排序

1. 分：选择一个基准，按基准把数组分成两个子数组。
2. 解：递归地对两个子数组进行快速排序。（直到把数组分成长度为1的子数组）
3. 合：合并有序数组

##### 14-2算法题

###### [374. 猜数字大小](https://leetcode-cn.com/problems/guess-number-higher-or-lower/)

解题步骤：

1. 分:计算中间元素，分割数组。
2. 解:递归地在较大或者较小子数组进行二分搜索。
3. 合:不需要此步，因为在子数组中搜到就返回了。

```js
/**
 * @param {number} n
 * @return {number}
 */
var guessNumber = function(n) {
    const rec = (low, heigh) => {
        if(low > heigh) {return}
        const mid = Math.floor( (low + heigh) / 2);
        const res = guess(mid) //  int guess(int num) 来获取猜测结果
        if(res == 0) {
            return mid;
        }else if( res == 1) {
            return rec(mid + 1, heigh)
        }else {
            return rec(1, mid -1 )
        }
    }
    return rec(1, n) // 1 到 n 随机选择一个数字
};
```

###### [226. 翻转二叉树](https://leetcode-cn.com/problems/invert-binary-tree/)

解题思路：

1. 分：获取左右二叉树
2. 解：递归左右子树，再进行兑换
3. 合：返回一个树（翻转后的）

```js
/**
 * @param {TreeNode} root
 * @return {TreeNode}
 */
var invertTree = function(root) {
    if(!root) {return null;}
    // 获取左右二叉树
    // let left = root.left;
    // let right = root.right;
    return {
        val: root.val,
        left: invertTree(root.right),
        right: invertTree(root.left)
    }
};
```

###### [100. 相同的树](https://leetcode-cn.com/problems/same-tree/)

解题思路：

1. 分：获取左右二叉树
2. 解：递归左右子树，判断两个树的左子树和右子树是否相同
3. 合：中上结果合并，如果根节点也相同，那么树相同。

```js
/**
 * @param {TreeNode} p
 * @param {TreeNode} q
 * @return {boolean}
 */
var isSameTree = function(p, q) {
    if(!q && !p) { return true;}
    if(p && q && q.val == p.val && isSameTree(p.left, q.left) && isSameTree(p.right, q.right)) {
        return true;
    }else {
        return false;
    }
};
```

###### [101. 对称二叉树](https://leetcode-cn.com/problems/symmetric-tree/)

解题思路：

1. 分：获取左右二叉树
2. 解：解:递归地判断树1的左子树和树2的右子树是否镜像，树1的右子树和树2的左子树是否镜像。
3. 合：中上结果合并，如果根节点镜像也相同，那么树是对称二叉树。

```js
/**
 * @param {TreeNode} root
 * @return {boolean}
 */
var isSymmetric = function(root) {
    if(!root) {return true;}
    const isMirror =(l, r) => {
        if(!l&&!r) { return true}
        if(l && r && l.val === r.val && isMirror(l.left, r.right)&&isMirror(l.right, r.left)){
            return true;
        }
        return false;
    }
    return isMirror(root.left, root.right)
};
```

#### 15、 算法思想之“动态规划”

##### 15-1动态规划是什么？

1. 动态规划是**算法设计**中的一种方法。
2. 它将一个问题分解为**相互重叠**的**子问题**，通过反复求解子问题，来解决原来的问题。

举个栗子：斐波那契数列

![1624506160989.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ac9719ae01b34b6fbba7562c735ddaef~tplv-k3u1fbpfcp-watermark.image)

1. 定义子问题: `F(n) = F(n-1) + F(n-2)`。
2. 反复执行:从`2`循环到`n`,执行上述公式。

##### 15-2算法题

###### [70. 爬楼梯](https://leetcode-cn.com/problems/climbing-stairs/)

```js
/**
 * @param {number} n
 * @return {number}
 */
var climbStairs = function(n) {
    if(n < 2) {return 1;}
    const dp = [1,1];
    for(let i = 2; i <= n; i++) {
        dp[i] = dp[i-1] + dp[i - 2]
    }
    return dp[n]
};
```

###### [198. 打家劫舍](https://leetcode-cn.com/problems/house-robber/)

解题思路：

1. `f(k) =`从前`k`个房屋中能偷窃到的最大数额。
2. `Ak =`第`k`个房屋的钱数。
3. `f(k) = max(f(k-2) + Ak, f(k- 1))`

解题步骤：

1. 定义子问题: `f(k) = max(f(k-2) + Ak, f(k- 1))`。
2. 反复执行:从`2`循环到`n`,执行上述公式。

```js
/**
 * @param {number[]} nums
 * @return {number}
 */
var rob = function(nums) {
    if(nums.length === 0) { return 0;}
    const dp = [0 ,nums[0]];
    for(let i = 2; i <= nums.length; i++) {
        dp[i] = Math.max(dp[i - 2] + nums[i -1], dp[i - 1])
    }
    return dp[nums.length]
};
```

#### 16、 算法思想之“贪心算法”

##### 16-1贪心算法

1. 贪心算法是**算法设计**中的一种方法。
2. 期盼通过每个阶段的**局部最优**选择，从而达到全局的最优。
3. 结果并**不一定是最优**。

**贪心算法不一定是最优解，举个栗子**

**零钱兑换**

```js
1、
输入：coins = [1,2,4] a, amount = 11;
输出：3;
解释：11 = 5 + 5 + 1; 优先选择金额较大的

2、
输入：coins = [1,3,4] a, amount = 6;
输出：3;
解释：6 = 4 + 1 + 1; 优先选择金额较大的。
但是我们可以选择3+3 从而让输出结果是2，这才是最优解。
```

##### 16-2算法题

###### [455. 分发饼干](https://leetcode-cn.com/problems/assign-cookies/)

解题思路

1. 局部最优:既能满足孩子，还消耗最少。
2. 先将“较小的饼干”分给“胃口最小"的孩子。

解题步骤

1. 对饼干数组和胃口数组升序排序。
2. 遍历饼干数组，找到能满足第一个孩子的饼干。
3. 然后继续遍历饼干数组，找到满足第二、三、.... 、n个孩子的饼干。

```js
/**
 * @param {number[]} g
 * @param {number[]} s
 * @return {number}
 */
var findContentChildren = function(g, s) {
    g = g.sort((a,b) => a - b)
    s = s.sort((a,b) => a - b);
    let j = 0;
    for(let i = 0; i< s.length; i++) {
        if(s[i] >= g[j]) {
            j++;
        }
    }
    return j;
};
```

###### [122. 买卖股票的最佳时机 II](https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-ii/)

解题思路

1. 前提:  上帝视角，知道未来的价格。
2. 局部最优:见好就收，见差就不动，不做任何长远打算。

解题步骤

1. 新建一个变量，用来统计总利润。
2. 遍历价格数组，如果当前价格比昨天高，就在昨天买，今天卖，否则就不交易。
3. 遍历结束后，返回利润。

```js
/**
 * @param {number[]} prices
 * @return {number}
 */
var maxProfit = function(prices) {
    let profits = 0; // 利润
    if(prices.length == 0) {return 0;}
    for(let i = 0; i < prices.length; i++) {
        if(prices[i+1] > prices[i]) {
            profits += prices[i+1] - prices[i]
        }
    }
    return profits
};
```

#### 17、 算法思想之“回溯算法”

##### 17-1回溯算法是什么？

1. 回溯算法是算法设计中的一种方法。
2. 回溯算法是一种**渐进式**寻找并构建问题解决方式的策略。
3. 回溯算法会先从一个可能的动作开始解决问题，如果不行,就回溯并选择另一个动作，直到将问题解决。

**所谓回溯，就是走了一条路，发现走不通，拐回来原点再走另一条路**

什么问题可以用回溯算法？

1. 有很多路。（比喻）
2. 这些路里，有死路,也有出路。（比喻）
3. 通常需要递归来模拟所有的路。（比喻）

##### 17-2算法题

###### [46. 全排列](https://leetcode-cn.com/problems/permutations/)

解题思路

1. 要求: 1、所有排列情况; 2、没有重复元素。
2. 有出路、有死路。
3. 考虑使用回溯算法。

解题步骤

1. 用递归模拟出所有情况。
2. 遇到包含重复元素的情况，就回溯（递归结束）。
3. 收集所有到达递归终点的情况，并返回（数组长度多少，就是多少）。

```js
/**
 * @param {number[]} nums
 * @return {number[][]}
 */
var permute = function(nums) {
    let res = [];
    const backTrack =(path) => {
        if(path.length === nums.length) {
            res.push(path);
            return;
        }
        nums.forEach(n => {
            if(path.includes(n)) {return;} // 有重复数字的，之前返回，不走递归
            backTrack(path.concat(n))
        })
    }
    backTrack([]);
    return res;
};
```



###### [78. 子集](https://leetcode-cn.com/problems/subsets/)

解题思路

1. 要求: 1、所有子集 2、没有重复元素。
2. 有出路、有死路。
3. 考虑使用回溯算法。

解题步骤

1. 用递归模拟出所有情况。
2. 保证接的数字都是后面的数字。
3. 收集所有到达递归终点的情况，并返回。

```js
/**
 * @param {number[]} nums
 * @return {number[][]}
 */
var subsets = function(nums) {
    let res = [];
    const backTrack =(path,l,start) => {
        if(path.length === l) {
            res.push(path);
            return;
        }
        for(let i = start; i<nums.length; i++) {
            backTrack(path.concat(nums[i]), l, i + 1) // 保证子集是有序的。
        }
    }
   for(let i = 0; i<= nums.length; i++) {
    //    i:路径长度 ，0 起始位置
        backTrack([],i,0)
   }
    return res;
};
```

